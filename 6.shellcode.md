例：Linux下编写Shellcode 输出 Hello World   /* */中为相关知识可不看

​		基本过程是首先使用汇编通过系统调用的方式实现程序功能，编译成可执行文件，然后使用 objdump 进行机器码提取

​		要输出一个 hello world，可以通过 write 函数来实现，通过下面的方法查找 write 函数的系统调用号（找出来的是十进制的）

```
cat /usr/include/asm/unistd_32.h | grep write
cat /usr/include/asm/unistd_64.h | grep write
```

![image-20220903173550984](6.shellcode.assets/image-20220903173550984.png)

寄存及RAX 是存放系统调用号的，这里就应该是1

使用 `man 2 write` 可以找到 write 函数的参数 

/*

```
apt-get install manpages-de  manpages-de-dev  manpages-dev glibc-doc manpages-posix-dev manpages-posix  //Ubuntu默认是没有完全安装man手册的，执行此段命令安装man手册  
```

| 数字 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| 1    | 可执行程序或 Shell 命令                                      |
| 2    | 系统调用（内核提供的函数）                                   |
| 3    | 库调用                                                       |
| 4    | 特殊文件（通常位于 /dev 目录）                               |
| 5    | 文件格式和约定（比如 /etc/passwd）                           |
| 6    | 游戏                                                         |
| 7    | 杂项（包和一些约定）Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7) |
| 8    | 系统管理命令（通常是 root 用户执行的命令）                   |
| 9    | 内核相关的文件 Kernel routines [Non standard]                |

*/

write函数：

==ssize_t write(int fd, const void *buf, size_t count);==

​		第一个参数是三种输出模式

| 0        | 1        | 2        |
| -------- | -------- | -------- |
| stdin    | stdout   | stderr   |
| 标准输入 | 标准输出 | 标准错误 |

​		第二个参数是字符串的指针

​		第三个参数是输出的字数

​	**64 位的程序，寄存器传参：rdi, rsi, rdx, rcx, r8, r9 剩下的才用栈**，所以 rdi 应该是 1，rsi 应该是字符串的地址，rdx 应该是长度

编写代码 hello-world.asm

```
global _start	;_start就像C程序的main函数一样特殊，是整个程序的入口，链接器在
				;链接时会查找目标文件中的_start符号代表的地址，把它设置为整个程序	
				;的入口地址，所以每个汇编程序都要提供一个_start符号并且用.globl声明
				
section .text 	   ;段声明，保存代码，是只读和可执行的。
_start:
   mov rax, 1               ;设置rax寄存器为write的系统调用号
   mov rdi, 1               ;设置rdi为write的第一个参数
   mov rsi, hello_world     ;设置rsi为write的第二个参数
   mov rdx, length          ;设置rdx为write的第三个参数
   syscall                  ;调用syscall
   
section .data	;段声明，保存程序的数据，是可读可写的，相当于C程序的全局变量。
   hello_world: db 'hello world',0xa       ;字符串hello world以及换行
   length: equ $-hello_world               ;获取字符串长度
```

然后汇编、链接：       /*需要安装nasm汇编编译器*/

```
nasm -felf64 hello-world.asm -o hello-world.o   //汇编
ld hello-world.o -o hello-world					//链接
./hello-world   								//执行
```

![image-20220903192301309](6.shellcode.assets/image-20220903192301309.png)

出现段错误是因为没有正常退出，可以源文件中的syscall后加上

```
mov rax,60
mov rdi,0
syscall
```

运行结果如下：

![image-20220903193322251](6.shellcode.assets/image-20220903193322251.png)

使用objdump提取shellcode（具体意思不懂）

```
objdump -M intel -D hello-world | grep '[0-9a-f]:' | grep -v 'file' | cut -f2 -d: | cut -f1-7 -d' ' | tr -s ' ' | tr '\t' ' ' | sed 's/ $//g' | sed 's/ /\\\x/g' | paste -d '' -s
```

运行完会提取出对应的机器码：

```
\xb8\x01\x00\x00\x00\xbf\x01\x00\x00\x00\x48\xbe\x00\x20\x40\x00\x00\x00\x00\x00\xba\x0c\x00\x00\x00\x0f\x05\xb8\x3c\x00\x00\x00\xbf\x00\x00\x00\x00\x0f\x05\x68\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64\x0a
```

然后在C语言中使用shellcode：

```
#include<stdio.h>
#include<string.h>
unsigned char code[]="\xb8\x01\x00\x00\x00\xbf\x01\x00\x00\x00\x48\xbe\xd8\x00\x60\x00\x00\x00\x00\x00\xba\x0c\x00\x00\x00\x0f\x05\xb8\x3c\x00\x00\x00\xbf\x00\x00\x00\x00\x0f\x05\x68\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64\x0a";

int main(){
 printf("shellcode length:%d\n",(int)strlen(code));
 int (*ret)()=(int(*)())code;
 ret();
}
```

编译时需要关掉栈不可执行

![](6.shellcode.assets/image-20220903194330306.png)

​		运行还是会出错，因为 shellcode 中存在一些 \x00，我们称为：bad character，它会使字符串截断，就没有后面什么事情了，所以要想办法消除这些 bad character

| bad character列表 |      |          |
| :---------------: | ---- | -------- |
|        00         | \0   | null     |
|        0A         | \n   | 回车换行 |
|        FF         | \f   | 换页     |
|        0D         | \r   | 回车     |

**消除bad character**

来看一下这些 bad character 是怎么形成的

```
objdump -d -M intel hello-world
```

![image-20220903194654275](6.shellcode.assets/image-20220903194654275.png)

针对这种的 `mov eax,0x1`，可以使用对寄存器的一部分赋值实现，比如：`mov al,0x1`

还可以通过 `xor rax,rax` 先把 rax 置为 0，然后 `add rax,0x1` 实现

/*

```
XOR destination, source
```

如果两个位的值相同，则结果位等于 0；否则结果位等于 1。

*/

```
global _start
section .text
_start:
   mov al,0x1               
	xor  rdi,rdi
	add  rdi,0x1            
   mov rsi, hello_world    
   mov rdx, length       
   syscall   
   
section .data
   hello_world: db 'hello world',0xa    ;0xa换行   
   length: equ $-hello_world 
   
mov rax,60
mov rdi,0
syscall
```

对应改动源文件后再次观察：

![](6.shellcode.assets/image-20220903195510973.png)

 		 可以看到消除一部分bad character 

还有就是地址的问题，下面有几种方法解决：

**relative address technique**

​	通过 rel 相对 RIP 偏移找到变量的位置，等到程序执行的时候会使用 rip 减去与 hello_world 的差值，从而获得 hello_world 在内存中的位置

```
global _start
section .text			;段保存代码，是只读和可执行的，后面那些指令都属于.text段。
_start:       			;程序的入口
	jmp code
	hello_world:db 'hello world',0xa  
	   ;DB作为汇编语言中的伪操作命令，它用来定义操作数占用的字节数。
	   ;DB/BYTE（DefineByte），每个字节只占一个字节单元。读完一个，偏移量加1
	   ;编译时，DB后面的数据将视为纯数据而不是指令代码。
code:
 mov al,1               
 xor  rdi,rdi
 add  rdi,1
	
	lea rsi,[rel hello_world]
		 ;
		 ;假设：SI=1000H , DS=5000H, (51000H)=1234H
　　		;执行指令 LEA BX , [SI]后，BX=1000H
　　		;执行指令 MOV BX , [SI]后，BX=1234H
		 ; rel ： rip - related  以当前rip为基地址, 立即数为偏移量
	xor rdx,rdx
	add rdx,12
;mov rsi, hello_world     
;mov rdx, length          

   syscall                 

	xor rax,rax
	add rax,60
	xor rdi,rdi
;mov rax,60
;mov rdi,0
syscall
```

提取字节码，并放在C程序中验证

```
nasm -felf64 hello-world.asm -o hello-world.o   //汇编
ld hello-world.o -o hello-world					//链接
./hello-world   								//执行
objdump -M intel -D hello-world | grep '[0-9a-f]:' | grep -v 'file' | cut -f2 -d: | cut -f1-7 -d' ' | tr -s ' ' | tr '\t' ' ' | sed 's/ $//g' | sed 's/ /\\\x/g' | paste -d '' -s
```

```
#include <stdio.h>
#include <string.h>
int main()
{
    const char shellcode[] =  "\xeb\x0c\x68\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64\x0a\xb0\x01\x48\x31\xff\x48\x83\xc7\x01\x48\x8d\x35\xe4\xff\xff\xff\x48\x31\xd2\x48\x83\xc2\x0c\x0f\x05\x48\x31\xc0\x48\x83\xc0\x3c\x48\x31\xff\x0f\x05";   //当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度
    printf("Shellcode length: %d bytes\n",(int)strlen(shellcode));
    (*(void(*)())shellcode)();
}
```

```
gcc test.c -o test -z execstack -z norelro -no-pie -g
```



第二种    **jmp-call technique**

通过在字符串前面 call 把字符串的地址压栈，然后 pop 获取

```
global _start
section .text

_start:
 jmp string          ;首先会跳转到 string 
 
code:
 pop rsi             ;此时可以把压在栈上的hello_world的地址获取到
 mov al,1
 xor rdi,rdi
 add rdi,1
 xor rdx,rdx
 add rdx,12
 syscall

 xor rax,rax
 add rax,60
 xor rdi,rdi
 syscall
 
string:
 call code          ;call会把返回地址压栈，然后执行code的代码
 hello_world:db 'hello world',0xa
```

第三种  **stack technique**

借助栈来存放，需要提前设置好字符串的十六进制逆序，用python的 string[::-1].encode('hex')

```
>>> string = "hello world\n"
>>> string[::-1].encode('hex')
'0a646c726f77206f6c6c6568'
```

```
global _start
section .text

_start:

 xor rax,rax
 add rax,1
 mov rdi,rax
 push 0x0a646c72
 mov rbx,0x6f77206f6c6c6568
 push rbx
 mov rsi,rsp        ;rsp就是栈顶的地址，也就是字符串在栈上的地址
 xor rdx,rdx
 add rdx,12
 syscall

 xor rax,rax
 add rax,60
 xor rdi,rdi
 syscall
```



# 1.简介

​	 	shellcode 通常用机器语言编写，是一段用于软件漏洞而执行的代码，因其目的常常是让攻击者获得目标机器的命令行 shell 而得名。随着发展，shellcode 现在代表将插入到漏洞利用程序中以完成所需任务的任何字节码。由于shellcode要直接操作寄存器和函数，所以必须是十六进制的形式。

​		shellcode的目的是要让目标程序以不同于设计者预期的方式运行，而操作的程序的方法之一就是强制它产生系统调用（system,call,syscall)。通过系统调用，直接访问系统内核。

​		在Linux里有两个方法来执行系统调用，间接的方法是c函数包装（libc），直接的方法是用汇编指令（通过把适当的参数加载到寄存器，然后调用int 0x80软中断）

# 2.shellcode原理

## 2.1理解系统调用

 		操作系统作为用户与计算机硬件之间的接口，向上提供简单易用的服务。包括命令接口和程序接口。其中程序接口由一组系统调用组成。

![image-20220903164350483](6.shellcode.assets/image-20220903164350483.png)

​		**“系统调用”**是操作系统提供给应用程序（程序员、编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。

### 系统调用与库函数的区别

操作系统对上层提供系统调用的接口，应用程序通过汇编语言的形式直接使用系统调用。

一般高级语言中会将系统调用封装成库函数，以隐藏系统调用的一些细节，使得进行系统调用更加方便。

## 2.2例  常见的系统调用exit（）

==gedit exit.c==

```
int main(void)
{
    exit(0);
}
```

==gcc exit.c -static -o exit==

然后使用gdb反汇编生成的二进制文件：

