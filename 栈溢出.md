# 栈溢出

## 1.x86和x86_64的区别

​		主要区别就是内存地址的大小。不过即便 **x86_64** 内存地址有64位长用户空间也只能使用前47位，要牢记这点，因为当你指定一个大于0x00007fffffffffff的地址时会抛出一个异常。那也就意味着0x4141414141414141会抛出异常而0x0000414141414141是安全的。

​		事实上还有很多其他的不同但是考虑到本文的目的不了解所有的差异也没关系。

## 2.漏洞代码片段

```
//bof.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main(int argc, char **argv) {
char buffer[256];
if(argc != 2) {
exit(0);
}
printf("%p\n", buffer);
strcpy(buffer, argv[1]);
printf("%s\n", buffer);
return 0;
}

```

可以用gcc编译上述代码。

```
$ gcc -m64 bof.c -o bof -z execstack -fno-stack-protector -g
//-z 与关键字 execstack 一起直接传递给链接器。
//-fno-stack-protector -o test test.c 禁用栈保护
```

## 3.触发溢出

首先确认一下确实可以让这个进程崩溃。

```
$ ./bof $(python -c 'print "A" * 300')
```

![image-20220901193929208](../../Blogs/asstes/image-20220901193929208.png)

然后确认我们控制的RIP指令指针

![image-20220901194323015](../../Blogs/asstes/image-20220901194323015.png)

然后单步执行，在执行完strcpy后观察rsp

```
x/20xg $rsp   //查 64 位程序内存信息
//x 指令用于查看内存地址的值
```

![image-20220901200220220](../../Blogs/asstes/image-20220901200220220.png)

继续单步执行，接着主函数(main)中的leave指令把rsp指向0x7fffffffdef8。 此时栈的情况：

![image-20220901200848307](../../Blogs/asstes/image-20220901200848307.png)

观察各个寄存器的情况

![image-20220901202037025](../../Blogs/asstes/image-20220901202037025.png)

![image-20220901202051779](../../Blogs/asstes/image-20220901202051779.png)

![image-20220901202103391](../../Blogs/asstes/image-20220901202103391.png)

在次单步执行时程序结束，但是没有控制rip，原因就是覆盖了太多位  

最大的地址是0x00007fffffffffff   而我们尝试用0x4141414141414141去溢出了。

## 0x04 控制RIP

​	用个小一点的缓冲区去溢出这样指向rsp的地址就会像0x0000414141414141一样了。

​	通过简单的数学运算就可以很轻松地算出我们缓冲区的大小。我们知道缓冲区开始于0x7fffffffddf0。Leave指令之后rsp将指向0x7fffffffdef8。

```
0x7fffffffdef8-0x7fffffffddf0 = 0x108 -> 十进制的264
```

因此，我们可以修改缓冲区

```
"A" * 264 + "B" * 6
```

rsp指向的地址应该像0x0000424242424242一样正常了。那样就能控制RIP。

```
 run $(python -c 'print "A" * 264 + "B" * 6')   //再次执行 在执行到函数返回时 观察rip
```

![image-20220901213656196](../../Blogs/asstes/image-20220901213656196.png)



#### ALSR

aslr是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。如今Linux，Windows等主流操作系统都已采用了该技术。



ALSR由 `/proc/sys/kernel/randomize_va_space` 决定，默认为2

```
0 - 表示关闭进程地址空间随机化

1 - 表示将mmap的基址，stack和vdso页面随机化。

2 - 表示在1的基础上增加栈（heap）的随机化。
```

要关闭ALSR，只需将`randomize_va_space`里面的内容改为0即可。

修改该文件不能直接用 `vi` 或者 `vim` 进行修改,也不能直接 `sudo echo 0 > /proc/sys/kernel/randomize_va_space`

使用此条命令即可关闭ALSR：`sudo sh -c "echo 0 > /proc/sys/kernel/randomize_va_space"`



